<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis扩展功能-4（Pipeline、事务与Bloom等...）"><meta name="keywords" content="Redis"><meta name="author" content="Inaction"><meta name="copyright" content="Inaction"><title>Redis扩展功能-4（Pipeline、事务与Bloom等...） | Inaction's Blog</title><link rel="shortcut icon" href="/imdadul-hussain-u_oLPS_ZYSc-unsplash.jpg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?12b421fdad87d1edf2305ccb7229d2c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-8RMJ1F8ETC', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD"><span class="toc-number">1.</span> <span class="toc-text">Redis-扩展功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipelining-%E7%AE%A1%E9%81%93"><span class="toc-number">1.1.</span> <span class="toc-text">Pipelining(管道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipeline%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">Pipeline示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipeline%E7%AE%A1%E9%81%93%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">Pipeline管道压力测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BB%8E%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.</span> <span class="toc-text">Redis从文件批量插入数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AC%E7%A0%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">文件的转码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">文件导入的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">事务示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BC%80%E5%90%AF%E4%B8%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">事务的开启与执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">事务的执行先后顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">事务原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84WATCH"><span class="toc-number">1.3.3.</span> <span class="toc-text">事务的WATCH</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84DISCARD"><span class="toc-number">1.3.4.</span> <span class="toc-text">事务的DISCARD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.5.</span> <span class="toc-text">事务小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">Bloom(布隆过滤器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloom%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">Bloom是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloom%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8D%E5%90%8C%E7%AE%97%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">Bloom过滤器不同算法及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloom%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.3.</span> <span class="toc-text">Bloom模块安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloom%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88RedisBloom%E6%A8%A1%E5%9D%97%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">Bloom的数据结构（RedisBloom模块）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bloom-vs-Cuckoo"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">Bloom vs Cuckoo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bloom%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">Bloom的基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cuckoo%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">Cuckoo的基本用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98LRU-LFU%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">缓存LRU&#x2F;LFU算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">LRU回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%91%E4%BC%BCLRU%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">近似LRU算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LFU%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">LFU回收算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.</span> <span class="toc-text">过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#key%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text">key过期策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E6%89%AB%E6%8F%8F%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">定时扫描策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.3.</span> <span class="toc-text">过期的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%87%92%E6%83%B0%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.</span> <span class="toc-text">懒惰删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BD%BF%E7%94%A8unlink%E6%87%92%E6%83%B0%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.1.</span> <span class="toc-text">Redis使用unlink懒惰删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flush"><span class="toc-number">1.7.2.</span> <span class="toc-text">flush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF-Sync"><span class="toc-number">1.7.3.</span> <span class="toc-text">AOF Sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4%E7%82%B9"><span class="toc-number">1.7.4.</span> <span class="toc-text">更多异步删除点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESP%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.8.</span> <span class="toc-text">RESP通信协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E9%83%A8%E7%AE%80%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">Redis内部简化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32bit-VS-64bit"><span class="toc-number">1.9.1.</span> <span class="toc-text">32bit VS 64bit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">小对象压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ziplist"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">ziplist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#intset%E5%92%8Chashtable"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">intset和hashtable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E5%AF%B9%E8%B1%A1%E5%8E%8B%E7%BC%A9%E5%8F%82%E6%95%B0"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">小对象压缩参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.3.</span> <span class="toc-text">内存回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.9.4.</span> <span class="toc-text">内存分配算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#INFO%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.</span> <span class="toc-text">INFO指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%AF%8F%E7%A7%92%E5%8F%91%E9%80%81%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.1.</span> <span class="toc-text">Redis每秒发送的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%BF%9E%E6%8E%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">Redis连接客户端数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="toc-number">1.10.3.</span> <span class="toc-text">Redis内存占用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%A7%AF%E5%8E%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.10.4.</span> <span class="toc-text">复制积压缓冲区大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%89%E5%85%A8"><span class="toc-number">1.11.</span> <span class="toc-text">Redis安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%AE%89%E5%85%A8"><span class="toc-number">1.11.1.</span> <span class="toc-text">端口安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL%E4%BB%A3%E7%90%86"><span class="toc-number">1.11.2.</span> <span class="toc-text">SSL代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">1.11.3.</span> <span class="toc-text">Redis安全通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spiped%E5%8E%9F%E7%90%86"><span class="toc-number">1.11.4.</span> <span class="toc-text">spiped原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spiped%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.5.</span> <span class="toc-text">spiped使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis6-0%E7%89%88%E6%9C%AC%E6%94%AF%E6%8C%81SSL-TLS"><span class="toc-number">1.11.6.</span> <span class="toc-text">redis6.0版本支持SSL&#x2F;TLS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SSL-TLS%E9%85%8D%E7%BD%AE"><span class="toc-number">1.11.6.1.</span> <span class="toc-text">SSL&#x2F;TLS配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLS%E7%AB%AF%E5%8F%A3%E4%BE%A6%E5%90%AC"><span class="toc-number">1.11.6.2.</span> <span class="toc-text">TLS端口侦听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%A4%E8%AF%81%E8%AF%81%E4%B9%A6"><span class="toc-number">1.11.6.3.</span> <span class="toc-text">客户端认证证书</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6"><span class="toc-number">1.11.6.4.</span> <span class="toc-text">复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">1.11.6.5.</span> <span class="toc-text">集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5"><span class="toc-number">1.11.6.6.</span> <span class="toc-text">哨兵</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/imdadul-hussain-u_oLPS_ZYSc-unsplash.jpg"></div><div class="author-info__name text-center">Inaction</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">54</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">13</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Friend Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://www.ji4n.cn/">Jen</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(img/wuwei.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Inaction's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Redis扩展功能-4（Pipeline、事务与Bloom等...）</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-05-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/Redis/">Redis</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Redis-扩展功能"><a href="#Redis-扩展功能" class="headerlink" title="Redis-扩展功能"></a>Redis-扩展功能</h1><h2 id="Pipelining-管道"><a href="#Pipelining-管道" class="headerlink" title="Pipelining(管道)"></a>Pipelining(管道)</h2><p>Pipeline是Redis服务提供的一种特别技术，这种技术可以加速Redis的存储效率，但是Pipeline本身并不是Redis服务器直接提供的技术，是由客户端提供的，跟服务器没有什么直接的关系</p>
<p>Redis其实与HTTP协议相似，都是请求-应答的模式，客户端请求传送给服务器，服务器处理完后，再响应回复给客户端，期间需要消耗一个数据包的来回时间。当你执行多个请求时，那就需要花费多个数据包来回时间</p>
<p>那么一个请求相当于一个写，一个响应相当于一个读，客户端是进行 写-读-写-读 完整指令的，如果将读写顺序调整，改成 写-写-读-读，这些指令就可以同时完成。这样的连续 写-读 就只需要花费一次网络来回</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210327211424622.png"></p>
<p>这就是Pipeline的作用，客户端通过对管道中的指令列表改变读写顺序来减少网络的的IO时间，指令越多，效果越好</p>
<h3 id="Pipeline示例"><a href="#Pipeline示例" class="headerlink" title="Pipeline示例"></a>Pipeline示例</h3><p>安装一个nc连接，通过nc对redis进行一个socket连接，然后等待服务端响应</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y nmap-ncat</span><br><span class="line">$ nc localhost 6379</span><br><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line">+<span class="selector-tag">OK</span></span><br><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span></span><br><span class="line">+<span class="selector-tag">OK</span></span><br><span class="line"><span class="selector-tag">keys</span> *</span><br><span class="line">*2</span><br><span class="line">$2</span><br><span class="line"><span class="selector-tag">k2</span></span><br><span class="line">$2</span><br><span class="line"><span class="selector-tag">k1</span></span><br></pre></td></tr></table></figure>
<p>也可以通过系统的“|”进行连接写入</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo -e &quot;set k3 99\nincr k3\n get k2&quot; | nc localhost 6379</span><br><span class="line">+<span class="selector-tag">OK</span></span><br><span class="line"><span class="selector-pseudo">:100</span></span><br><span class="line">$2</span><br><span class="line"><span class="selector-tag">v2</span></span><br><span class="line">$ redis-cli get k3</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Pipeline管道压力测试"><a href="#Pipeline管道压力测试" class="headerlink" title="Pipeline管道压力测试"></a>Pipeline管道压力测试</h3><p>Redis自来一款压力测试工具redis-benchmark，使用这个工具可以进行管道的测试</p>
<p>对于普通的set指令进行测试，QPS大约3w/s左右</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t set -q</span><br><span class="line"><span class="selector-tag">SET</span>: 31407.04 <span class="selector-tag">requests</span> <span class="selector-tag">per</span> <span class="selector-tag">second</span></span><br></pre></td></tr></table></figure>
<p>可以加入Pipeline选项P参数，它表示单个管道内并行的其你去数量，如下所示，当P=2时，QPS达到了5w/s，当P=3时达到了9w/s</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t set -P 2 -q</span><br><span class="line"><span class="selector-tag">SET</span>: 58582.31 <span class="selector-tag">requests</span> <span class="selector-tag">per</span> <span class="selector-tag">second</span></span><br><span class="line">$ redis-benchmark -t set -P 3 -q</span><br><span class="line"><span class="selector-tag">SET</span>: 90954.55 <span class="selector-tag">requests</span> <span class="selector-tag">per</span> <span class="selector-tag">second</span></span><br></pre></td></tr></table></figure>
<p>还可以通过多个请求，通过不加管道和加管道的差异</p>
<ul>
<li>-n测试请求的个数</li>
<li>-t是只运行以逗号分隔的测试列表，</li>
<li>-r是对SET/GET/INCR使用随机键，对SADD使用随机值</li>
<li>-P是以管道传输，默认1表示无管道</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t set -n 1000000 -r 1000 </span><br><span class="line">====== SET ======8.10</span><br><span class="line">  1000000 <span class="selector-tag">requests</span> <span class="selector-tag">completed</span> <span class="selector-tag">in</span> 35.12 <span class="selector-tag">seconds</span></span><br><span class="line">  50 <span class="selector-tag">parallel</span> <span class="selector-tag">clients</span></span><br><span class="line">................................省略...........................</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t set -n 1000000 -r 1000 -P 2</span><br><span class="line">====== SET ======</span><br><span class="line">  1000066 <span class="selector-tag">requests</span> <span class="selector-tag">completed</span> <span class="selector-tag">in</span> 19.40 <span class="selector-tag">seconds</span></span><br><span class="line">  50 <span class="selector-tag">parallel</span> <span class="selector-tag">clients</span></span><br><span class="line">................................省略...........................</span><br></pre></td></tr></table></figure>
<p>可以看出使用管道之后速度明显是更快完成100w个请求，使用越多的管道，则执行的时间越少。当然如果发现QPS已经上不去了，就代表CPU处理能力已经达到了瓶颈，Redis的单线程CPU消耗已经100%了，所以无法在继续提升</p>
<h2 id="Redis从文件批量插入数据"><a href="#Redis从文件批量插入数据" class="headerlink" title="Redis从文件批量插入数据"></a>Redis从文件批量插入数据</h2><p>通过一条条写入的执行命令，这对于大量的数据，实在麻烦了些，如果能将一条条命令存储到文件中，那麻烦的步骤会少很多，Redis就支持文件批量插入数据，可看如下步骤</p>
<p><strong>创建文件</strong></p>
<p>首先创建一个文件，将要执行的命令写入进去</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt</span><br><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line"><span class="selector-tag">set</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span></span><br><span class="line"><span class="selector-tag">sadd</span> <span class="selector-tag">xuexi</span> 90 <span class="selector-tag">wu</span> 80 <span class="selector-tag">li</span> 70 <span class="selector-tag">liu</span></span><br><span class="line"><span class="selector-tag">hset</span> <span class="selector-tag">username</span> <span class="selector-tag">user</span> <span class="selector-tag">liu</span></span><br></pre></td></tr></table></figure>
<p>执行导入，导入使用cat和redis-cli的命令组合，一个用来读取文件内容，一个用来发送文件到redis执行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt | redis-cli</span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 5</span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>然后进入redis查看是否成功导入</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -p 6379</span><br><span class="line">127.0.0.1<span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">keys</span> *</span><br><span class="line">1) &quot;<span class="selector-tag">xuexi</span>&quot;</span><br><span class="line">2) &quot;<span class="selector-tag">username</span>&quot;</span><br><span class="line">3) &quot;<span class="selector-tag">k2</span>&quot;</span><br><span class="line">4) &quot;<span class="selector-tag">k1</span>&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到，输入的命令是多少，那么返回的记录就是多少，并且告诉我们执行的结果。如果有更多的导入指令，可以使用–pipe这个参数来启动pipe协议，减少返回结果的输出，还能更快的执行命令</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.txt | redis-cli --pipe</span><br><span class="line"><span class="selector-tag">All</span> <span class="selector-tag">data</span> <span class="selector-tag">transferred</span>. <span class="selector-tag">Waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">the</span> <span class="selector-tag">last</span> <span class="selector-tag">reply</span>...</span><br><span class="line"><span class="selector-tag">Last</span> <span class="selector-tag">reply</span> <span class="selector-tag">received</span> <span class="selector-tag">from</span> <span class="selector-tag">server</span>.</span><br><span class="line"><span class="selector-tag">errors</span>: 0, <span class="selector-tag">replies</span>: 4</span><br></pre></td></tr></table></figure>
<h3 id="文件的转码"><a href="#文件的转码" class="headerlink" title="文件的转码"></a>文件的转码</h3><p>redis-cli中只支持dos格式的换行符\r\n，如果是Linux、Mac下或者Windows下，最好转个码，如果导入失败，可能就是没有转码的原因</p>
<p>下载的转码的命令，进行转码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y unix2dos</span><br><span class="line">$ unix2dos a.txt </span><br><span class="line"><span class="selector-tag">unix2dos</span>: <span class="selector-tag">converting</span> <span class="selector-tag">file</span> <span class="selector-tag">a</span><span class="selector-class">.txt</span> <span class="selector-tag">to</span> <span class="selector-tag">DOS</span> <span class="selector-tag">format</span> ...</span><br></pre></td></tr></table></figure>
<h3 id="文件导入的注意事项"><a href="#文件导入的注意事项" class="headerlink" title="文件导入的注意事项"></a>文件导入的注意事项</h3><ul>
<li>导入指令文件最好不要一行结束后留空格或留空行，否则可能会出现问题</li>
<li>文件导入前，先转码，这样可以保证文件是可导入的。当然要注意，如果转码失败，导入肯定也失败</li>
</ul>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>为了保证连续多个操作的原子性，数据库通常都会存在事务的支持。比如mysql，每个事务的操作指令begin、commit和roollback，begin是开启事务，commit时提交事务，rollback是事务的回滚</p>
<p>Redis在事务的处理形式也差不多，命令分别是multi、exec、discard。multi是事务的开始，exec是事务的执行，discard是事务的丢弃，可以看出redis是没有回滚功能的，虽然没有回滚功能，但是这种做法也有如下优点：</p>
<ul>
<li>Redis的事务命令只会因为错误的语法才会报错，或是使用错误类型。从实用性的角度来看，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中发现，而不是出现在生产环境</li>
<li>Redis的特点就是速度快，所以在不需要回滚的功能，则可以在内容保持简单和快速</li>
</ul>
<p>可以通过帮助查看redis的事务，获取事务命令</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">help</span> <span class="keyword">@transactions</span></span><br><span class="line"></span><br><span class="line">  DISCARD -</span><br><span class="line">  <span class="attribute">summary:</span> Discard all commands issued after MULTI</span><br><span class="line">           丢弃MULTI之后发出所有命令</span><br><span class="line">  <span class="attribute">since:</span> <span class="number">2.0</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  EXEC -</span><br><span class="line">  <span class="attribute">summary:</span> Execute all commands issued after MULTI</span><br><span class="line">           执行MULTI之后发出所有命令</span><br><span class="line">  <span class="attribute">since:</span> <span class="number">1.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  MULTI -</span><br><span class="line">  <span class="attribute">summary:</span> Mark the start of a transaction block</span><br><span class="line">           标记事务快的开始</span><br><span class="line">  <span class="attribute">since:</span> <span class="number">1.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  UNWATCH -</span><br><span class="line">  <span class="attribute">summary:</span> Forget about all watched keys</span><br><span class="line">           去除所有已观看的按键</span><br><span class="line">  <span class="attribute">since:</span> <span class="number">2.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  WATCH key [key ...]</span><br><span class="line">  <span class="attribute">summary:</span> Watch the given keys to determine execution of the MULTI/EXEC block</span><br><span class="line">           监视给定的键以确定MULTI/EXEC快的执行</span><br><span class="line">  <span class="attribute">since:</span> <span class="number">2.2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="事务示例"><a href="#事务示例" class="headerlink" title="事务示例"></a>事务示例</h3><h4 id="事务的开启与执行"><a href="#事务的开启与执行" class="headerlink" title="事务的开启与执行"></a>事务的开启与执行</h4><p>multi开始事务时，所有的指令在exec之前是不执行的，而是缓存在服务器的一个事务队列中，当服务器收到exec指令，则开始执行事务队列，执行完后一次性返回所有命令的运行结果</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">MULTI</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">EXEC</span></span><br><span class="line">1) <span class="selector-tag">OK</span></span><br><span class="line">2) <span class="selector-tag">OK</span></span><br></pre></td></tr></table></figure>
<p>QUEUED返回结果是一个简单字符串，它表示指令已经被服务器缓存在队列中了</p>
<h4 id="事务的执行先后顺序"><a href="#事务的执行先后顺序" class="headerlink" title="事务的执行先后顺序"></a>事务的执行先后顺序</h4><p>redis是一个单进程的服务，所以在执行过程都会以队列的形式进行处理，不用担心被其他指令打搅，保证执行的“原子性”，比如下图的两个操作，删除一个key和查询一个key，如果删除key的执行先到达到，那么在查询的就会出现nil</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210329144348795.png"></p>
<p><strong>操作示例</strong></p>
<p>打开两个窗口，同时开启事务，分别执行上述图的命令</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line"></span><br><span class="line">//窗口1</span><br><span class="line">&gt; <span class="selector-tag">multi</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line"></span><br><span class="line">//窗口2</span><br><span class="line">&gt; <span class="selector-tag">MULTI</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">del</span> <span class="selector-tag">k1</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">exec</span></span><br><span class="line">1) (<span class="selector-tag">integer</span>) 1</span><br><span class="line"></span><br><span class="line">//回到窗口1</span><br><span class="line">&gt; <span class="selector-tag">exec</span></span><br><span class="line">1) (<span class="selector-tag">nil</span>)</span><br></pre></td></tr></table></figure>
<h3 id="事务原子性"><a href="#事务原子性" class="headerlink" title="事务原子性"></a>事务原子性</h3><p>事务原子性可以简单的理解，在指事务执行过程中要么全部成功，要么全部失败，但redis事务是不支持原子性的，如下面例子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">multi</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">incr</span> <span class="selector-tag">k2</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k3</span> <span class="selector-tag">v3</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">EXEC</span></span><br><span class="line">1) &quot;<span class="selector-tag">v1</span>&quot;</span><br><span class="line">2) (<span class="selector-tag">error</span>) <span class="selector-tag">ERR</span> <span class="selector-tag">value</span> <span class="selector-tag">is</span> <span class="selector-tag">not</span> <span class="selector-tag">an</span> <span class="selector-tag">integer</span> <span class="selector-tag">or</span> <span class="selector-tag">out</span> <span class="selector-tag">of</span> <span class="selector-tag">range</span></span><br><span class="line">3) <span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k3</span></span><br><span class="line">&quot;<span class="selector-tag">v3</span>&quot;</span><br></pre></td></tr></table></figure>
<p>上述的例子事务过程中间有一个执行失败了因为之前设置的k2是字符串，所以不能使用数学运算。但事务的失败，并不影响后面的执行，所以我们查看k3的值依然是设置到的。可以看出Redis事务是不具备”原子性”，而只是满足了事务的“隔离性”中的串行化</p>
<h3 id="事务的WATCH"><a href="#事务的WATCH" class="headerlink" title="事务的WATCH"></a>事务的WATCH</h3><p>WATCH使得EXEC命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，如果这个前提不能满足，事务是不会执行的，如下述的例子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//窗口1</span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span>                </span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">watch</span> <span class="selector-tag">k1</span>               //开启监控</span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">multi</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">keys</span> *</span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//窗口2</span><br><span class="line">&gt; <span class="selector-tag">multi</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">sdfdgsd</span>       //修改<span class="selector-tag">k1</span>的值     </span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">exec</span></span><br><span class="line">1) <span class="selector-tag">OK</span></span><br><span class="line"></span><br><span class="line">//在回到窗口1执行<span class="selector-tag">exex</span>，会发现什么也没有执行，因为<span class="selector-tag">k1</span>值已经变动，所以窗口1的事务不会执行</span><br><span class="line">&gt; <span class="selector-tag">exec</span></span><br><span class="line">(<span class="selector-tag">nil</span>)</span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;<span class="selector-tag">sdfdgsd</span>&quot;</span><br></pre></td></tr></table></figure>
<p>WATCH命令还可以被调用多次，对多个键从WATCH执行之后开始生效，直到调用EXEC为止，如下述操作</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">watch</span> <span class="selector-tag">k1</span> <span class="selector-tag">k2</span> <span class="selector-tag">k3</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br></pre></td></tr></table></figure>
<p>使用无参数的UNWATH命令可以手动取消对所有键的监视</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">unwatch</span> <span class="selector-tag">k1</span> <span class="selector-tag">k2</span> </span><br></pre></td></tr></table></figure>
<h3 id="事务的DISCARD"><a href="#事务的DISCARD" class="headerlink" title="事务的DISCARD"></a>事务的DISCARD</h3><p>Redis事务提供一个discard指令，用于丢弃事务缓存队列中的所有指令，不过要在exec之前执行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> 10</span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;10&quot;</span><br><span class="line">&gt; <span class="selector-tag">multi</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">incr</span> <span class="selector-tag">k1</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">incr</span> <span class="selector-tag">k1</span></span><br><span class="line"><span class="selector-tag">QUEUED</span></span><br><span class="line">&gt; <span class="selector-tag">discard</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;10&quot;</span><br></pre></td></tr></table></figure>
<h3 id="事务小结"><a href="#事务小结" class="headerlink" title="事务小结"></a>事务小结</h3><ul>
<li>从事务的执行先后顺序，可以看出事务的执行是原子性的（对于每一个指令），开启事务之后执行exec，那么事务的所有指令都会被执行</li>
<li>但事务原子性是不支持，开启事务到结束事务过程中，每个事务都可以被执行，不管是否发生错误。但这样只满足了事务的隔离性，并没有满足原子性</li>
<li>使用watch监视的key过程中，事务只能在所有被监视键都没有被修改的前提下执行。如果被修改，则执行返回nil（这个功能是通过redis的check-and-set（CAS）行为，也称乐观锁）</li>
<li>事务不支持回滚，保持简单和速度</li>
</ul>
<h2 id="Bloom-布隆过滤器"><a href="#Bloom-布隆过滤器" class="headerlink" title="Bloom(布隆过滤器)"></a>Bloom(布隆过滤器)</h2><h3 id="Bloom是什么"><a href="#Bloom是什么" class="headerlink" title="Bloom是什么"></a>Bloom是什么</h3><p>可以理解Bloom过滤器是不怎么精确的set结构，使用它的方法判断某个对象存不存在，比如：黑客攻击你的服务器，大量搜索一些网站没有的数据，缓存也没有，就会全部压到数据库，使数据库处理压力增大，处理效率降低，甚至整个数据库崩溃。那么Bloom过滤器就是处理该问题的一种方法</p>
<p>Bloom过滤器有可能会误判，不是真正的到达100%精确。但设置参数合理，它的精确度也可以很高，只有小小的误判概率，这个误判可以说是当Bloom布隆器说某个值存在时，这个值有可能不存在；当它说某个不存在时，那这个值肯定不存在。</p>
<h3 id="Bloom过滤器不同算法及原理"><a href="#Bloom过滤器不同算法及原理" class="headerlink" title="Bloom过滤器不同算法及原理"></a>Bloom过滤器不同算法及原理</h3><ul>
<li>Client实现bloom算法，自己承载bitmap（位图），redis服务只做缓存</li>
<li>Client实现bloom算法，将bitmap后置到redis，redis承载bitmap </li>
<li>Client没有算法，使用redis集成的bloom模块</li>
</ul>
<blockquote>
<p>注：这里的Client不是代表用户客户端，而是在redis前面的服务作为client（如web集群，spring等等服务）</p>
</blockquote>
<p>每个Bloom过滤器对应到Redis的数据结构里面的就是一个大型的位数组和几个不一样的无偏hash函数，所谓的无偏就是能够把元素的hash值均匀的分配，让元素被hash映射到位数组中，位置是随机的，比如下图元素e、g、f</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210331100422012.png"></p>
<p>当Bloom过滤器添加key时，会使用hash函数对key进行hash，算出一个整数索引值，，然后对位数组长度进行取模运算得到一个位置，每个hash函数都会算得一个不同的位置。再将位数组的这几个位置置为1，完成add添加的操作</p>
<p>向Bloom过滤器询问key是否存在时，跟add一样，也会把hash的几个位置算出来，看看位数组中这几个位置是否都为1，只要有一个位为0，就说明Bloom过滤器中这个key是不存在的。如果几个位都是1，也不能说明这个key就一定存在，只是极有可能存在，因为这些位被置为1可能是因为其他的key存在所致。如果这个位数组比较宽松，判断正确的概率就会很大，再者这个位数组比较拥挤，判断正确的概率就会降低。计算判断概率的公式复杂，大概了解就行</p>
<blockquote>
<p>注意：使用时不要让实际元素数量远大于初始化数量，当实际元素数量超出初始化数量时，要对Bloom过滤器进行重建，重新分配一个更大的过滤器，再将所有的历史元素批量添加进</p>
</blockquote>
<h3 id="Bloom模块安装"><a href="#Bloom模块安装" class="headerlink" title="Bloom模块安装"></a>Bloom模块安装</h3><p>这里的部署，我是通过redis集成的模块安装，需要进入官网找到Bloom模块</p>
<ul>
<li>可以通过GitHub提供docket进行安装</li>
<li>也可以通过下载包之后编译安装</li>
</ul>
<p>这里演示的是下载之后编译安装</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210330155428792.png"></p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210330155501200.png"></p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210330155546086.png"></p>
<p>通过wget命令下载blomm过滤器，如果下载不了，则选择下载在本地的.zip压缩包，然后进行上传</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wegt https://github.com/RedisBloom/RedisBloom.git</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">$ rz -E</span><br><span class="line">$ ls</span><br><span class="line"><span class="selector-tag">RedisBloom-master</span><span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure>
<p>解压之后进行make编译</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unzip RedisBloom-master.zip </span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>加载redisblomm.so文件到redis，加载之后进行测试，如果导入之后多出BF.xx和CF.xx的命令，那么就是导入成功。可通过help @generic</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server --loadmodule /server/soft/RedisBloom-master/redisbloom.so</span><br><span class="line">$ help @generic</span><br></pre></td></tr></table></figure>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210330161839592.png"></p>
<blockquote>
<p>PS：加载模块也可以通过配置文件进行加载：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ vi /opt/redis_cluster/6379.conf</span><br><span class="line"># <span class="selector-tag">Load</span> <span class="selector-tag">modules</span> <span class="selector-tag">at</span> <span class="selector-tag">startup</span>. <span class="selector-tag">If</span> <span class="selector-tag">the</span> <span class="selector-tag">server</span> <span class="selector-tag">is</span> <span class="selector-tag">not</span> <span class="selector-tag">able</span> <span class="selector-tag">to</span> <span class="selector-tag">load</span> <span class="selector-tag">modules</span></span><br><span class="line"># <span class="selector-tag">it</span> <span class="selector-tag">will</span> <span class="selector-tag">abort</span>. <span class="selector-tag">It</span> <span class="selector-tag">is</span> <span class="selector-tag">possible</span> <span class="selector-tag">to</span> <span class="selector-tag">use</span> <span class="selector-tag">multiple</span> <span class="selector-tag">loadmodule</span> <span class="selector-tag">directives</span>.</span><br><span class="line">#</span><br><span class="line"># <span class="selector-tag">loadmodule</span> /<span class="selector-tag">path</span>/<span class="selector-tag">to</span>/<span class="selector-tag">my_module</span><span class="selector-class">.so</span></span><br><span class="line"># <span class="selector-tag">loadmodule</span> /<span class="selector-tag">path</span>/<span class="selector-tag">to</span>/<span class="selector-tag">other_module</span><span class="selector-class">.so</span></span><br><span class="line"><span class="selector-tag">loadmodule</span> /<span class="selector-tag">server</span>/<span class="selector-tag">soft</span>/<span class="selector-tag">RedisBloom-master</span>/<span class="selector-tag">redisbloom</span><span class="selector-class">.so</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Bloom的数据结构（RedisBloom模块）"><a href="#Bloom的数据结构（RedisBloom模块）" class="headerlink" title="Bloom的数据结构（RedisBloom模块）"></a>Bloom的数据结构（RedisBloom模块）</h3><blockquote>
<p>模块的使用与操作地址：<a target="_blank" rel="noopener" href="https://oss.redislabs.com/redisbloom/">https://oss.redislabs.com/redisbloom/</a></p>
</blockquote>
<p>RedisBloom模块提供了四种数据结构，可扩展的Bloom filter，cuckoo filter(布谷鸟过滤器），count-min sketch（计算最小草图）和top-k。数据结构</p>
<ul>
<li>Bloom and cuckoo filters 用于高度精确的确定元素是否是set的成员</li>
<li>count-min sketch 通常用于确定流中事件的频率，可以查询计算最小草图，以获得给定时间概率的估计值</li>
<li>top-k 维护k个最常出现的项目列表</li>
</ul>
<h4 id="Bloom-vs-Cuckoo"><a href="#Bloom-vs-Cuckoo" class="headerlink" title="Bloom vs Cuckoo"></a>Bloom vs Cuckoo</h4><p>Bloom过滤器通过在插入项目时表现出更好性能和可伸缩性（如果经常添加数据集到你的项目，则Blomm过滤器会是理想的原则）</p>
<p>Cuckoo过滤器可以快速执行检查操作，以及可以删除（Bloom过滤器是不能删除元素的）</p>
<h4 id="Bloom的基本用法"><a href="#Bloom的基本用法" class="headerlink" title="Bloom的基本用法"></a>Bloom的基本用法</h4><p>bf.add和bf.exists。bf.add添加元素，bf.exists查询元素是否存在，用法与set集合的sadd和sismember。bf.add只能添加一个元素，如果要添加多个需要使用bf.madd，同样如果需要查询多个元素是否存在，需要用到bf.mexists指令</p>
<p><strong>操作示例</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">BF</span><span class="selector-class">.ADD</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">BF</span><span class="selector-class">.EXISTS</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">BF</span><span class="selector-class">.EXISTS</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br><span class="line">&gt; <span class="selector-tag">BF</span><span class="selector-class">.MADD</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span> <span class="selector-tag">a2</span> <span class="selector-tag">c2</span></span><br><span class="line">1) (<span class="selector-tag">integer</span>) 1</span><br><span class="line">2) (<span class="selector-tag">integer</span>) 1</span><br><span class="line">3) (<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">BF</span><span class="selector-class">.MEXISTS</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span> <span class="selector-tag">a2</span> <span class="selector-tag">c2</span></span><br><span class="line">1) (<span class="selector-tag">integer</span>) 1</span><br><span class="line">2) (<span class="selector-tag">integer</span>) 1</span><br><span class="line">3) (<span class="selector-tag">integer</span>) 1</span><br></pre></td></tr></table></figure>
<p>测试的结果很精确，但毕竟是少量的，在添加多个元素下，Bloom过滤器才会出现误判</p>
<h4 id="Cuckoo的基本用法"><a href="#Cuckoo的基本用法" class="headerlink" title="Cuckoo的基本用法"></a>Cuckoo的基本用法</h4><p>Cuckoo只有cf.add和cf.addnx添加key，没有批量添加，但是有批量查询cf.mexists，命令的操作方法与blomm过滤器差不多，但是cuckoo还多出了cf.del可以删除key</p>
<p><strong>操作示例</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">cf</span><span class="selector-class">.add</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">CF</span><span class="selector-class">.EXISTS</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; <span class="selector-tag">cf</span><span class="selector-class">.add</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">cf</span><span class="selector-class">.add</span> <span class="selector-tag">k2</span> <span class="selector-tag">c2</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">cf</span><span class="selector-class">.mexists</span> <span class="selector-tag">k2</span> <span class="selector-tag">v2</span> <span class="selector-tag">c2</span></span><br><span class="line">1) (<span class="selector-tag">integer</span>) 1</span><br><span class="line">2) (<span class="selector-tag">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; <span class="selector-tag">cf</span><span class="selector-class">.del</span> <span class="selector-tag">k2</span> <span class="selector-tag">c2</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">cf</span><span class="selector-class">.exists</span> <span class="selector-tag">k2</span> <span class="selector-tag">c2</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 0</span><br></pre></td></tr></table></figure>
<h2 id="缓存LRU-LFU算法"><a href="#缓存LRU-LFU算法" class="headerlink" title="缓存LRU/LFU算法"></a>缓存LRU/LFU算法</h2><h3 id="LRU回收算法"><a href="#LRU回收算法" class="headerlink" title="LRU回收算法"></a>LRU回收算法</h3><p>当Redis内存超出了物理内存限制时，内存的数据就会开始于磁盘产生频繁的交换（swap）。这会使得Redis的性能急剧下降，对于高访问两点redis来说，这样极大限制redis的存取效率</p>
<p>为了限制最大使用的内存，Redis了提供了配置参数maxmemory来限制内存超出期望的大小。当超出限制时，Redis提供了集中可选的策略（maxmemory-policy）来让用户自己决定使用哪种方法进行存取空间的限制</p>
<ul>
<li>noeviction：尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。这种策略不会继续服务写请求，读请求可以进行，这样保证不会丢失数据（对于redis作为缓存是不会选择该策略的，但作为数据库则默认选择该策略，来保证数据不丢失）</li>
<li>allkeys-lru：尝试回收最少使用的键（LRU），使得新添加的数据有空间释放（淘汰的key对象是全体的key集合，而不只是过期key的集合，也就是没有设置过期时间的也会被淘汰）</li>
<li>volatile-lru：尝试回收最少使用的键（LRU），使得新添加的数据有空间释放（但仅限于设置了过期时间的key，没有设置过期的时间key不会淘汰）</li>
<li>allkeys-random：跟allkey-lru相同，淘汰的全体key是随机的（太随意）</li>
<li>volatile-random：跟volatile-lru相同，淘汰的过期key是随机的（太随意）</li>
<li>volatile-ttl：回收再过期集合的键，并且优先回收存货时间（TTL）较短的键（这种策略会根据设置的TTL值，TTL值越小的将被淘汰）</li>
</ul>
<p>如果上述的策略，除了noeviction，没有键满足回收的条件的话，那么久相当于没有设置，和noeviction差不多</p>
<p>volatile-xxx策略只针对过期时间的key进行淘汰，allkeys-xxx策略是所有key进行淘汰，如果将redis作为缓存使用，那么选择allkeys-xx策略优先，客户端写缓存时不必携带过期时间，可以让缓存更高效。如果还想同时使用Redis的持久化功能，那就使用volatile-xxx策略，这样可以保留没有设置过期时间的key，不会被LRU算法淘汰</p>
<h3 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h3><p>Redis使用的是还有近似LRU算法，它跟LRU算法还不太一样，之所以使用LRU算法，那是因为其需要消耗大量的额外内存。近似LRU算法在现有数据结构的基础上使用随机采样法来淘汰元素，能够到达和LRU算法非常相似的效果</p>
<p>LRU算法对少量的keys进行取样，然后收取其中一个最好的key（被访问时间最早的），比如：Redis在执行写操作时，发现内存超出maxmemroy设置的值，就会执行一个LRU淘汰算法，算法会随机取样除5（数据可以自己设置）个key，然后淘汰最旧的key。如果淘汰后内存还超出maxmemory，那就会继续取样淘汰，知道内存低于maxmemory为止</p>
<p>取样的参数通过maxmemory-samples进行调整，如果是设置allkeys，就从所有的key集合中随机取样，如果是volatile，就从带过期时间的key集合做随机取样，取样的key默认值是5</p>
<p><strong>真实的LRU算法与近似的算法通过下图图像对比</strong></p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210331140054592.png"></p>
<ul>
<li>浅灰色是已经被回收的对象</li>
<li>灰色待是没有被回收的对象</li>
<li>绿色是被添加的对象</li>
</ul>
<p>在LRU实现的理论中，在旧键中的第一半将会过期，Redis的LRU算法则是概率的过期旧的键，对于Redis2.8和3.0，3.0算法效果更接近LRU算法。因为Redis3.0在算法中增加了淘汰池，淘汰池是一个数组，它的大小是maxmemory_samples，在每一次淘汰循环中，新的随机得出的key列表会和淘汰池中的key列表进行融合，淘汰掉最旧的一个key之后，保留剩余较旧的key列表放入淘汰池中，等待下一次循环</p>
<blockquote>
<p>注意：LRU只是个预测键将如何被访问的模型。另外，如果你的数据访问模式非常接近幂定律，大部分的访问将集中在一个键的集合中，LRU的近似算法将会处理的很好</p>
</blockquote>
<h3 id="LFU回收算法"><a href="#LFU回收算法" class="headerlink" title="LFU回收算法"></a>LFU回收算法</h3><p>LFU是Redis4.0开始有的，全称是Least Frequently Used，表示按最近的访问频率进行淘汰，它更精准地表示一个key被访问的热度。如果一个key长时间不馁访问，只是偶然被访问了一下，那在LRU算法下，是不容易被淘汰的。因为LRU算法认为这个key是热键，而LFU算法需要追踪最近一段时间的访问频率，如果某个key只是偶然被访问一下，是不足以为热键的，它需要在近一段时间访问多次才会被LFU认为是热键</p>
<p>配置LFU模式，可使用一下策略如下：</p>
<ul>
<li>volatile-lfu：对带过期时间段key执行LFU淘汰算法</li>
<li>allkeys-lfu：对所有的key执行LFU淘汰算法</li>
</ul>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><h3 id="key过期策略"><a href="#key过期策略" class="headerlink" title="key过期策略"></a>key过期策略</h3><p>Redis所有的数据结构都可以设置过期时间，过期时间一到，就会被自动删除。Redis会将每个设置了过期时间的key放入一个独立的字典中，以后会定时遍历这个字段来删除到期的key。除了定时遍历，Redis还使用惰性策略来删除过期的key，就是在客户端访问这个key的时候，对这个key过期时间进行检查，如果过期了就立即删除。可以说定时遍历是集中处理，而惰性策略就是零散处理。</p>
<h3 id="定时扫描策略"><a href="#定时扫描策略" class="headerlink" title="定时扫描策略"></a>定时扫描策略</h3><p>Redis默认每秒进行10次过期扫描，过期扫描不会遍历过期字典中所有的key，而是采用一种贪心策略。比如：从过期字典中随机选出20个key，删除这个20个key中已经过期的key，如果过期的key的比例超过1/4，那就重复字典选key</p>
<p>同时，为了保证过期扫描不会出现循环过度，导致线程卡死的现象，算法还增加了扫描时间的上限，默认不会超过25ms</p>
<p><strong>假设一个大型的Redis实例中所有的key在同一时间过期了，会出现怎样的结果？</strong></p>
<p>Redis会持续扫描过期字典（循环多次），直到过期字典中过期的key变得稀疏，才会定制（循环次数）下降。这就会导致线上读写请求出现明显的卡顿情况。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的CPU消耗</p>
<p>当客户端请求到来时，服务器如果正好进入过期扫描状态，客户端的请求将会等待至少25ms后才会进行处理，如果客户端将超时时间设置得比较短。如10ms，那么就会出现大量的链接因为超时而关闭，业务端就会出现很多异常，而且这时你还无法从Redis的slowlog中看到慢查询记录，因为慢查询指的是逻辑处理过程慢，不包含等待时间</p>
<p>所以业务开发人员一定要注意过期时间，如果有大批量的key过期，要给过期时间设置一个随机范围，而不能全部在同一时间过期</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在目标过期时间上增加一天的随机事件</span><br><span class="line"><span class="selector-tag">redis</span><span class="selector-class">.expire_at</span>(<span class="selector-tag">key</span>, <span class="selector-tag">random</span><span class="selector-class">.randint</span>(86400) + <span class="selector-tag">expire_ts</span>)</span><br></pre></td></tr></table></figure>
<p>在一些活动系统中，因为活动是一期一会，下一期活动举办时，前面几期活动的很多数据都可以丢弃了，所以需要给相关的活动数据设置一个过期时间，以减少不必要的Redis内存占用。如果不加注意，你可能会将过期时间设置为活动结束时间在增加一个常量的冗余时间，如果参与活动的人数太多，就会导致大量的key同时过期</p>
<h3 id="过期的问题"><a href="#过期的问题" class="headerlink" title="过期的问题"></a>过期的问题</h3><ul>
<li>设置过期key，重新读之后，会不会根据访问的时间延长？</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">expire</span> <span class="selector-tag">k1</span> 50</span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">ttl</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 48</span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;<span class="selector-tag">v1</span>&quot;</span><br><span class="line">&gt; <span class="selector-tag">ttl</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 39</span><br></pre></td></tr></table></figure>
<p>从示例可以看出，在发生读时，设置过期的key是不会根据访问的时间进行延长</p>
<ul>
<li>设置过期key，在重新设置值之后，key的过期是否会重置时间？</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">expire</span> <span class="selector-tag">k1</span> 50</span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">ttl</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 48</span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">a1</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;<span class="selector-tag">a1</span>&quot;</span><br><span class="line">&gt; <span class="selector-tag">ttl</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) <span class="selector-tag">-1</span></span><br></pre></td></tr></table></figure>
<p>从示例可以看出，如果发生写，就会直接剔除key的过期时间</p>
<h2 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a>懒惰删除</h2><h3 id="Redis使用unlink懒惰删除"><a href="#Redis使用unlink懒惰删除" class="headerlink" title="Redis使用unlink懒惰删除"></a>Redis使用unlink懒惰删除</h3><p>删除指令del，会直接释放对象的内存，大部分情况下，这个指令非常快，没有明显延迟。不过如果被删除的key是一个非常大的对象。比如一个包含了上千万个元素的hash，那么删除操作就会导致单线程卡顿</p>
<p>Redis为了解决卡顿这个问题，在4.0版本中引入了unlink指令，它能对删除操作进行懒处理，丢给后台线程来异步回收内存</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span> <span class="selector-tag">ex</span> 50</span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">ttl</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 48</span><br><span class="line">&gt; <span class="selector-tag">unlink</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">ttl</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) <span class="selector-tag">-2</span></span><br></pre></td></tr></table></figure>
<p>但是不是所有的unlink操作都会延后处理，如果对应key所占用的内存很小，延后处理就没有必要了，这时候Redis会将对应key的内存立即回收，跟del指令一样</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>Redis提供了flushdb和flushall指令，用来清空数据库，这也是极其缓慢的操作。Redis4.0同样给这个两个指令带来了异步化，在指令后面增加async参数就可以丢给后台线程慢慢处理</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">flushall</span> <span class="selector-tag">async</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br></pre></td></tr></table></figure>
<h3 id="AOF-Sync"><a href="#AOF-Sync" class="headerlink" title="AOF Sync"></a>AOF Sync</h3><p>Redis需要每秒（该数量可设置）1次同步AOF日志到磁盘，确保消息尽量不丢失。但需要调用sync函数，这个操作比较耗时，会导致主线程的效率下降，所以Redis也将这个操作移到异步线程来完成。执行AOF Sync操作的线程是一个独立的异步线程，和前面的懒惰删除线程不是一个线程，同样它也有一个属于自己的任务队列，队列里只用来存放AOF Sync任务</p>
<h3 id="更多异步删除点"><a href="#更多异步删除点" class="headerlink" title="更多异步删除点"></a>更多异步删除点</h3><p>除了del指令和flush操作之外，Redis在key的过期、LRU淘汰、rename指令过程中，也会实施回收内存。此外，还有一种特殊的flush操作，其发生于正在进行全量同步的从节点中，在接受完整的rdb文件后，也需要将当前的内存一次性清空，以加载整个rdb文件的内容到内存</p>
<p>Redis4.0位这些删除点也带来了异步删除机制，打开这些点需要额外的设置选项</p>
<ul>
<li>slave-lazy-flush：从节点接受完rdb文件后的flush操作</li>
<li>lazyfree-lazy-eviction：内存达到maxmemory时进行淘汰</li>
<li>lazyfree-lazy-expire key：过期删除</li>
<li>lazyfree-lazy-server-del rename：指令删除destKey</li>
</ul>
<h2 id="RESP通信协议"><a href="#RESP通信协议" class="headerlink" title="RESP通信协议"></a>RESP通信协议</h2><p>RESP是Redis序列化协议（Redis Serialization Protocol）的简写。它是一种直观的文本协议，实现过程简单，快速地被计算机解析</p>
<p>Redis协议将传输的结构数据分为5中最小单元类型，单元结束时统一加上回车换行符号\r\n</p>
<ul>
<li>单行字符串回复（单行回复）以“+”符号开头</li>
<li>多行字符串回复（批量回复）以“$”符号开头，后跟字符串长度</li>
<li>整数回复（正整形数字回复）值以“:”符号开头，后跟整数的字符串形式</li>
<li>错误消息（单行字符串回复的另一种展示形式）以“-”符号开头</li>
<li>数组（多个批量回复）以“*”号开头，后跟数组的长度</li>
</ul>
<p><strong>单行字符串（单行回复）</strong></p>
<p>状态回复（或者单行回复）以“+”开头，然后以“\r\n”结尾的单行字符串形式，如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">hello</span></span><br><span class="line"><span class="selector-tag">OK</span>          //客户端返回的显示</span><br><span class="line"></span><br><span class="line">+<span class="selector-tag">OK</span>\<span class="selector-tag">r</span>\<span class="selector-tag">n</span>     //实际服务端返回</span><br></pre></td></tr></table></figure>
<p><strong>多行字符串回复（批量回复）</strong></p>
<p>多行字符串回复被服务器用于返回一个单二进制安全字符串。服务器发送第一行回复，该行以“$”开始，后跟实际要发送的字节数，接着就是CRLF，然后是实际数据，最后是2个字节的CRLF。如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;<span class="selector-tag">hello</span>&quot;              // 客户端实际返回</span><br><span class="line">  </span><br><span class="line">$5\r\nhello\r\n      // 服务端实际返回 </span><br></pre></td></tr></table></figure>
<p>如果请求的值不存在，多行字符回复使用特殊的-1来作为数据长度，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">get</span> <span class="selector-tag">k2</span></span><br><span class="line">(<span class="selector-tag">nil</span>)               // 客户端实际返回</span><br><span class="line"></span><br><span class="line">$-1\r\n            // 服务端实际返回</span><br></pre></td></tr></table></figure>
<p><strong>整数回复（正整数）</strong></p>
<p>整数回复使用以“:”作为开头，如“:10\r\n”。像INCR、DECR或者STRLEN等用整形回复作为实际回复值，还有EXIST将true返回1，为false返回0。如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">list1</span> <span class="selector-tag">v1</span> <span class="selector-tag">v2</span> <span class="selector-tag">v3</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 3     //客户端实际返回</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:3</span>\<span class="selector-tag">r</span>\<span class="selector-tag">r</span>         //服务端实际返回</span><br></pre></td></tr></table></figure>
<p><strong>错误消息</strong></p>
<p>错误消息发送类似于状态回复。唯一的不同是第一个字节用“-”代替“+”。错误的消息即在你执行的过程使用错误的参数或者命令不存在等问题。如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">sset</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">error</span>) <span class="selector-tag">ERR</span> <span class="selector-tag">unknown</span> <span class="selector-tag">command</span> `<span class="selector-tag">sset</span>`, <span class="selector-tag">with</span> <span class="selector-tag">args</span> <span class="selector-tag">beginning</span> <span class="selector-tag">with</span>: `<span class="selector-tag">k1</span>`,  //客户端返回的显示</span><br><span class="line">...</span><br><span class="line"><span class="selector-tag">-</span>(<span class="selector-tag">error</span>) <span class="selector-tag">ERR</span> <span class="selector-tag">unknown</span> <span class="selector-tag">command</span> `<span class="selector-tag">sset</span>`, <span class="selector-tag">with</span> <span class="selector-tag">args</span> <span class="selector-tag">beginning</span> <span class="selector-tag">with</span>: `<span class="selector-tag">k1</span>`,\<span class="selector-tag">r</span>\<span class="selector-tag">n</span>  //服务端实现返回</span><br></pre></td></tr></table></figure>
<p><strong>数组回复（多个批量回复）</strong></p>
<p>数组回复，以“*”为开头，后跟实际要发送的行数以及CRLF，接着后面的参数跟多行字符串回复一样。像list类型的LRANGE指令返回多于一个单元素。用一个初始行作为前缀来指示多少个批量写在后面。如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">lpush</span> <span class="selector-tag">list1</span> <span class="selector-tag">v1</span> <span class="selector-tag">v2</span> <span class="selector-tag">v3</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 3             </span><br><span class="line">&gt; <span class="selector-tag">lrange</span> <span class="selector-tag">list1</span> 0 <span class="selector-tag">-1</span>     // 客户端实际回复</span><br><span class="line">1) &quot;<span class="selector-tag">v3</span>&quot;</span><br><span class="line">2) &quot;<span class="selector-tag">v2</span>&quot;</span><br><span class="line">3) &quot;<span class="selector-tag">v1</span>&quot;</span><br><span class="line"></span><br><span class="line">*3\r\n$2\r\nv3$2\r\nv2$2\r\nv1\r\n   // 服务端实际回复</span><br></pre></td></tr></table></figure>
<p>如果指定的key不存在，则被认为是空的列表，且数值0被当做数组回复计数值来发送：如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">lrange</span> <span class="selector-tag">list2</span> 0 <span class="selector-tag">-1</span></span><br><span class="line">(<span class="selector-tag">empty</span> <span class="selector-tag">array</span>)     // 客户端实际回复</span><br><span class="line"></span><br><span class="line">*0\<span class="selector-tag">r</span>\<span class="selector-tag">n</span>            // 服务端实际回复</span><br></pre></td></tr></table></figure>
<p>如果使用BLPOP指令超时，它返回nil多批量回复。这种类型多批量回复的计数器是-1，且值用nil来解析。如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">BLPOP</span> <span class="selector-tag">list1</span> 5</span><br><span class="line">(<span class="selector-tag">nil</span>)             // 客户端实际回复</span><br><span class="line">(5.09<span class="selector-tag">s</span>)          </span><br><span class="line"></span><br><span class="line">*<span class="selector-tag">-1</span>              // 服务端实际回复   </span><br></pre></td></tr></table></figure>
<p>而这种情况，客户端返回的是一个空对象，就不是一个空列表。</p>
<p><strong>嵌套消息</strong></p>
<p>scan命令可以用来扫描服务器包含的所有key列表，它是以游标的形式获取，一次只获取部分</p>
<p>scan命令返回的是一个嵌套数组。数组的第一个值表示游标的值，如果这个值为零，说明已经遍历完成。如果不为零，则可以使用下一个游标值继续遍历。数组的第二个值又是一个数组，这个数组就是key列表</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">...</span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k4</span> <span class="selector-tag">d</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">scan</span> 0</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;<span class="selector-tag">k2</span>&quot;</span><br><span class="line">   2) &quot;<span class="selector-tag">k4</span>&quot;</span><br><span class="line">   3) &quot;<span class="selector-tag">k3</span>&quot;</span><br><span class="line">   4) &quot;<span class="selector-tag">k1</span>&quot;</span><br></pre></td></tr></table></figure>
<p>上述是客户端实际回复，下面是服务端实际回复</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*2</span><br><span class="line">$1</span><br><span class="line">0</span><br><span class="line">*3</span><br><span class="line">$2</span><br><span class="line"><span class="selector-tag">k2</span></span><br><span class="line">$2</span><br><span class="line"><span class="selector-tag">k4</span></span><br><span class="line">$2</span><br><span class="line"><span class="selector-tag">k3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：Redis协议里有大量冗余回车换行符，但这不影响它成为一个互联网技术领域受欢迎的文本协议。因为使用来简单，易理解和易实现，有很多开源项目也是用RESP作为它的通讯协议</p>
</blockquote>
<h2 id="Redis内部简化"><a href="#Redis内部简化" class="headerlink" title="Redis内部简化"></a>Redis内部简化</h2><p>Redis是一个非常耗费内存的数据库，它的数据都会放在内存中，如果不注意节约内存使用，Redis就可能会出现溢出。虽然有LRU和LFU的这些回收策略，但是我也还是要关注如果去优化或压缩自己所用的内存。Redis作者为数据结构的内存占用增加了非常多的优化点，这些优化也是以牺牲代码的可读性为代价的，但都是值得的</p>
<h3 id="32bit-VS-64bit"><a href="#32bit-VS-64bit" class="headerlink" title="32bit VS 64bit"></a>32bit VS 64bit</h3><p>Redis如果使用32bit进行编译，内部所有数据结构所使用的指针空间占用会少一半。如果你的Redis使用内存不超过4GB，可以考虑使用32bit进行编译，能够节约大量的内存空间</p>
<p>4GB的容量作为一些小型站点的缓存数据已经是够了的，如果不足在通过添加的方式来解决</p>
<h3 id="小对象压缩存储"><a href="#小对象压缩存储" class="headerlink" title="小对象压缩存储"></a>小对象压缩存储</h3><h4 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h4><p>如果Redis内存管理的集合数据结构小，它会使用紧凑存储形式压缩存储。Redis的ziplist是一个紧凑的字节数组结构，每个元素之间是紧挨着的，如下图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210423120215479.png"></p>
<p>如果存储的是hash结构，那么key和value会作为两个entry被相邻存储</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">hset</span> <span class="selector-tag">us</span> <span class="selector-tag">user1</span> <span class="selector-tag">wu</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">hset</span> <span class="selector-tag">us</span> <span class="selector-tag">user2</span> <span class="selector-tag">li</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">object</span> <span class="selector-tag">encoding</span> <span class="selector-tag">us</span></span><br><span class="line">&quot;<span class="selector-tag">ziplist</span>&quot;</span><br></pre></td></tr></table></figure>
<p>如果它存储的是zset结果，那么value和score会作为两个entry被相邻存储</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">k1</span> 90 <span class="selector-tag">wu</span> </span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">zadd</span> <span class="selector-tag">k1</span> 80 <span class="selector-tag">li</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 1</span><br><span class="line">&gt; <span class="selector-tag">object</span> <span class="selector-tag">encoding</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;<span class="selector-tag">ziplist</span>&quot;</span><br></pre></td></tr></table></figure>
<h4 id="intset和hashtable"><a href="#intset和hashtable" class="headerlink" title="intset和hashtable"></a>intset和hashtable</h4><p>Redis的intset是一个紧凑的整数数组结构，用于存放元素都是整数且元素个数较少的set集合。</p>
<p>如果整数可以用uint16表示，那么intset的元素就是16位的数组。如果新加入的整数超过了unit16的表示范围，那么就使用uint32表示。如果新加入的元素超过了unit32的表示范围，那么就使用unit64表示。Redis支持set集合动态从uint16升级到unit32，再升级到uint64</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210423140943378.png"></p>
<p>操作如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">sadd</span> <span class="selector-tag">k1</span> 1 2 3</span><br><span class="line">(<span class="selector-tag">integer</span>) 3</span><br><span class="line">&gt; <span class="selector-tag">object</span> <span class="selector-tag">encoding</span> <span class="selector-tag">k1</span></span><br><span class="line">&quot;<span class="selector-tag">intset</span>&quot;</span><br></pre></td></tr></table></figure>
<p>如果set里存储的是字符串，那么set立即升级为hashtable结构</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">sadd</span> <span class="selector-tag">k2</span> <span class="selector-tag">v1</span> <span class="selector-tag">v2</span> <span class="selector-tag">v3</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 3</span><br><span class="line">&gt; <span class="selector-tag">object</span> <span class="selector-tag">encoding</span> <span class="selector-tag">k2</span></span><br><span class="line">&quot;<span class="selector-tag">hashtable</span></span><br></pre></td></tr></table></figure>
<h4 id="小对象压缩参数"><a href="#小对象压缩参数" class="headerlink" title="小对象压缩参数"></a>小对象压缩参数</h4><p>存储界限：当集合对象的元素不断增加，或者某个value值过大，这种小对象存储也会被升级为标准结构。Redis规定了小对象存储结构的限制条件如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>hash-max-ziplist-entries 512</td>
<td>hash的元素个数超过512就必须用标准结构存储</td>
</tr>
<tr>
<td>hash-max-ziplist-value 64</td>
<td>hash的任意元素的key/value的长度超过64就必须用标准结构存储</td>
</tr>
<tr>
<td>list-max-ziplist-entries 512</td>
<td>list的元素个数超过512就必须用标准结构存储</td>
</tr>
<tr>
<td>list-max-ziplist-value 64</td>
<td>list的任意元素的长度超过64就必须用标准结构存储</td>
</tr>
<tr>
<td>zset-max-ziplist-entries 128</td>
<td>zset的袁术个数超过128就必须用标准结构存储</td>
</tr>
<tr>
<td>zset-max-ziplist-value 64</td>
<td>zset的任意元素的长度超过64就必须用标准结构存储</td>
</tr>
<tr>
<td>set-max-intset-entries 512</td>
<td>set的整数元素个数超过612就必须用标准结构存储</td>
</tr>
</tbody></table>
<p>通过python脚本做一个实现，看看界限是否真的起作用</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">redis</span></span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis()</span><br><span class="line"># <span class="selector-tag">client</span><span class="selector-class">.delete</span>(&quot;<span class="selector-tag">k1</span>&quot;)</span><br><span class="line"><span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">range</span>(512):</span><br><span class="line">    <span class="selector-tag">client</span><span class="selector-class">.hset</span>(&quot;<span class="selector-tag">k1</span>&quot;, <span class="selector-tag">str</span>(<span class="selector-tag">i</span>), <span class="selector-tag">str</span>(<span class="selector-tag">i</span>))</span><br><span class="line"><span class="selector-tag">print</span> (<span class="selector-tag">client</span><span class="selector-class">.object</span>(&quot;<span class="selector-tag">encoding</span>&quot;, &quot;<span class="selector-tag">k1</span>&quot;))   // 获取对象的存结构</span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.hset</span>(&quot;<span class="selector-tag">k1</span>&quot;, &quot;512&quot;, &quot;512&quot;) </span><br><span class="line"><span class="selector-tag">print</span> (<span class="selector-tag">client</span><span class="selector-class">.object</span>(&quot;<span class="selector-tag">encoding</span>&quot;, &quot;<span class="selector-tag">k1</span>&quot;))   //再次获取超过512对象的存储结构</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;ziplist&#x27;</span><br><span class="line">&#x27;hashtable&#x27;</span><br></pre></td></tr></table></figure>
<p>查看当前hash键值数量</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">hlen</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 513</span><br></pre></td></tr></table></figure>
<p>可以看到当hash结构的元素个数超过512的时候，存储结构就发生了变化</p>
<p>接下来再试试递增value的长度，在python里面对字符串乘以一个整数n相当于重复n次</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">redis</span></span><br><span class="line"></span><br><span class="line">client = redis.StrictRedis()</span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.delete</span>(&quot;<span class="selector-tag">k1</span>&quot;)</span><br><span class="line"><span class="selector-tag">for</span> <span class="selector-tag">i</span> <span class="selector-tag">in</span> <span class="selector-tag">range</span>(64):</span><br><span class="line">    <span class="selector-tag">client</span><span class="selector-class">.hset</span>(&quot;<span class="selector-tag">k1</span>&quot;, <span class="selector-tag">str</span>(<span class="selector-tag">i</span>), &quot;0&quot; * (<span class="selector-tag">i</span>+1))</span><br><span class="line"><span class="selector-tag">print</span> (<span class="selector-tag">client</span><span class="selector-class">.object</span>(&quot;<span class="selector-tag">encoding</span>&quot;, &quot;<span class="selector-tag">k1</span>&quot;))</span><br><span class="line"><span class="selector-tag">client</span><span class="selector-class">.hset</span>(&quot;<span class="selector-tag">k1</span>&quot;, &quot;512&quot;, &quot;0&quot; * 65)</span><br><span class="line"><span class="selector-tag">print</span> (<span class="selector-tag">client</span><span class="selector-class">.object</span>(&quot;<span class="selector-tag">encoding</span>&quot;, &quot;<span class="selector-tag">k1</span>&quot;))</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;ziplist&#x27;</span><br><span class="line">&#x27;hashtable&#x27;</span><br><span class="line"></span><br><span class="line">&gt; <span class="selector-tag">hlen</span> <span class="selector-tag">k1</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 65</span><br></pre></td></tr></table></figure>
<p>可以看出来当hash结构的任意entry的value超过了64，存储结构就升级成标准结构了</p>
<h3 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h3><p>Redis并不总是将空闲内存立即归还给操作系统</p>
<p>如果当前redis内存有10GB，当你删除了1GB的key后，再去观察内存，会发现内存变化不会太大。原因是操作系统是以页为单位来回收内存的，这个页上只要还有一个key在使用，那么它就不能被回收。Redis虽然删除了1GB的key，但是这些key分散到了很多页面中，每个页面都还其他key存在，这就导致了内存不会被立即回收</p>
<p>不过，如果你执行flushdb，然后再观察内存，会发现内存确实被回收了。原因是所有的key都被删除了，大部分之前使用的页面都清理干净，所以就会立即被操作系统回收</p>
<p>Redis虽然无法保证立即回收已经删除的key的内存，但是它会重新使用那些尚未回收的空闲内存。</p>
<h3 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h3><p>内存分配需要适当的算法划分内存页，需要考虑内存碎片，需要平衡性能和效率</p>
<p>Redis为了保持自身结构的简单性，在内存分配方面直接丢给了第三方内存分配库去实现。目前Redis可以使用jemalloc(facebook)库来管理内存，也可以切换到tcmalloc(google)库，因为jemalloc的性能相比tcmalloc要稍好一些，所以Redis默认使用jemalloc</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">info</span> <span class="selector-tag">memory</span></span><br><span class="line"><span class="selector-tag">mem_allocator</span><span class="selector-pseudo">:jemalloc-5.1.0</span></span><br></pre></td></tr></table></figure>
<p>通过info memory指令可以看到Redis使用的mem_allocator是jemalloc</p>
<h2 id="INFO指令"><a href="#INFO指令" class="headerlink" title="INFO指令"></a>INFO指令</h2><p>在使用Redis时，有时会遇到很多问题需要诊断，在诊断之前需要了解Redis的运行状态，可以通过强大的Info指令，清楚的知道Redis内部一系列运行的参数</p>
<p>Info指令显示的信息繁多，分为9大块，每个块都有非常多的参数，9大块如下：</p>
<ul>
<li>Server：服务器运行的环境参数</li>
<li>Clients：客户端相关信息</li>
<li>Memory：服务器运行内存统计数据</li>
<li>Persistence：持久化信息</li>
<li>Stats：通用统计数据</li>
<li>Replication：主从复制相关信息</li>
<li>CPU：CPU使用情况</li>
<li>Cluster：集群相关信息</li>
<li>KeySpace：键值对统计数量信息</li>
</ul>
<p>Info可以一次性获取所有的信息，也可以按块获取信息</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有信息</span><br><span class="line">&gt; <span class="selector-tag">info</span></span><br><span class="line"></span><br><span class="line">// 获取内存相关信息</span><br><span class="line">&gt; <span class="selector-tag">info</span> <span class="selector-tag">memory</span></span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">info</span> <span class="selector-tag">CPU</span></span><br><span class="line">&gt; 获取<span class="selector-tag">CPU</span>相关信息</span><br></pre></td></tr></table></figure>
<p>下述的内容是挑选实用和常用的参数进行讲解，如果想了解全部的内容信息，可以查看[Redis官网文档][<a target="_blank" rel="noopener" href="https://redis.io/commands/info]">https://redis.io/commands/info]</a></p>
<h3 id="Redis每秒发送的指令"><a href="#Redis每秒发送的指令" class="headerlink" title="Redis每秒发送的指令"></a>Redis每秒发送的指令</h3><p>这个信息在Stats快里，可以通过info stats看到</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// <span class="selector-tag">ops_per_sec</span>：<span class="selector-tag">operations</span> <span class="selector-tag">per</span> <span class="selector-tag">second</span>，每秒操作数</span><br><span class="line">$ redis-cli info stats| grep ops</span><br><span class="line"><span class="selector-tag">instantaneous_ops_per_sec</span><span class="selector-pseudo">:256</span></span><br></pre></td></tr></table></figure>
<p>osp:256，也就是所有客户端每秒发送256条指令到服务器执行。在极限情况下，Redis可以每秒执行10万次指令。如果ops过高，可以考虑通过monitor指令快速观察一下究竟是哪些key被访问得比较频繁</p>
<p>从而在相应的业务上进行，以减少IO次数。monitor指令会瞬间吐出巨量的指令文本，所以一般在执行monitor后立即使用ctrl+c中断输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli monitor</span><br></pre></td></tr></table></figure>
<h3 id="Redis连接客户端数"><a href="#Redis连接客户端数" class="headerlink" title="Redis连接客户端数"></a>Redis连接客户端数</h3><p>连接的客户端数在Clients块里，可以通过info clients看到</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli info clients</span><br><span class="line"># <span class="selector-tag">Clients</span></span><br><span class="line"><span class="selector-tag">connected_clients</span><span class="selector-pseudo">:1</span>                // 正在连接的客户端数量</span><br><span class="line"><span class="selector-tag">client_recent_max_input_buffer</span><span class="selector-pseudo">:4</span></span><br><span class="line"><span class="selector-tag">client_recent_max_output_buffer</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">blocked_clients</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">tracking_clients</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">clients_in_timeout_table</span><span class="selector-pseudo">:0</span></span><br></pre></td></tr></table></figure>
<p>通过这个信息观察其数量，确定是否存在其他连接情况。如果发现数量不对劲，就可以使用client list指令列出所有的客户端链接地址来确定源头</p>
<p>关于客户端的数量，还有一个需要关注的参数，那就是rejected_connections，该参数字面可看出，表示超出最大连接数限制而被拒绝的客户端连接次数，如果这个数字多，则意味着服务器的最大连接数设置过低，需要吊证maxclients参数</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli info stats|grep reject</span><br><span class="line"><span class="selector-tag">rejected_connections</span><span class="selector-pseudo">:0</span></span><br></pre></td></tr></table></figure>
<h3 id="Redis内存占用"><a href="#Redis内存占用" class="headerlink" title="Redis内存占用"></a>Redis内存占用</h3><p>查案内存是在Memory块里</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli info memory |grep used|grep human</span><br><span class="line"><span class="selector-tag">used_memory_human</span><span class="selector-pseudo">:1.55M</span>        // 内存分配器（<span class="selector-tag">jemalloc</span>）从操作系统分配的内存总量</span><br><span class="line"><span class="selector-tag">used_memory_rss_human</span><span class="selector-pseudo">:11.74M</span>   // 操作系统看到的内存占用，<span class="selector-tag">top</span>命令看到的内存</span><br><span class="line"><span class="selector-tag">used_memory_peak_human</span><span class="selector-pseudo">:1.61M</span>   // <span class="selector-tag">Redis</span>内存消耗的峰值</span><br><span class="line"><span class="selector-tag">used_memory_lua_human</span><span class="selector-pseudo">:37.00K</span>   // <span class="selector-tag">lua</span> 脚本引擎占用的内存大小</span><br><span class="line"><span class="selector-tag">used_memory_scripts_human</span><span class="selector-pseudo">:0B</span>   // 脚本占用的内存大小</span><br></pre></td></tr></table></figure>
<p>如果单个redis内存占用过大，并且在业务上没有太多压缩的空间，可考虑集群化</p>
<h3 id="复制积压缓冲区大小"><a href="#复制积压缓冲区大小" class="headerlink" title="复制积压缓冲区大小"></a>复制积压缓冲区大小</h3><p>这个信息在Replication，可通过info replication查看</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli info replication |grep backlog</span><br><span class="line"><span class="selector-tag">repl_backlog_active</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">repl_backlog_size</span><span class="selector-pseudo">:1048576</span>         // 积压缓冲区大小</span><br><span class="line"><span class="selector-tag">repl_backlog_first_byte_offset</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">repl_backlog_histlen</span><span class="selector-pseudo">:0</span></span><br></pre></td></tr></table></figure>
<p>复制集积压缓冲区大小很重要，它严重影响主从复制的效率。当从节点因为网络原因临时断开了与主节点的连接，重新连接上后。这段断开的时间内发生了在主节点上的修改操作，而这些都会被放在积压缓冲区中，这样从节点可以通过积压缓冲区恢复中断的主从同步过程</p>
<p>积压缓冲区是环形的，后来的指令会覆盖掉前面的内容。如果从节点断开的时间过长，或者缓冲区的容量设置的小。都会导致从节点无法快速恢复中断的主从同步过程，因为中间的修改指令会被覆盖掉。这时从节点就会进入全量同步模式，非常耗费CPU和网络资源</p>
<p>如果有多个从节点复制，积压缓冲区是共享的，它不会因为从节点过多而线性增长。如果实力的修改指令请求频繁，那就把积压的缓冲区设置大一些，几十个MB大小</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli info stats |grep sync</span><br><span class="line"><span class="selector-tag">sync_full</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">sync_partial_ok</span><span class="selector-pseudo">:0</span></span><br><span class="line"><span class="selector-tag">sync_partial_err</span><span class="selector-pseudo">:0</span>   // 半同步失败次数</span><br></pre></td></tr></table></figure>
<p>通过查看sysc_partial_err变量的次数来决定是否需要扩大积压缓冲区，它表示主从半同步复制失败的次数</p>
<h2 id="Redis安全"><a href="#Redis安全" class="headerlink" title="Redis安全"></a>Redis安全</h2><p>Redis有一些非常危险的指令，这些指令会对Redis的稳定以及数据造成严重的影响。比如使用keys指令会导致Redis卡顿，flushdb和flushall会让Redis的所有数据全部清空你，那么如何避免这些指令被误操作呢</p>
<p>Redis在配置文件中提供了rename-command指令用于将某些危险的指令修改成特别的名称，用来避免人为误操作。比如在配置文件的security块中增加如下内容</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/redis/6379.conf</span><br><span class="line"><span class="selector-tag">rename-command</span> <span class="selector-tag">keys</span> <span class="selector-tag">abckeys</span></span><br></pre></td></tr></table></figure>
<p>通过上述的参数改变了使用的指令，如果想执行keys，就能敲keys指令了，而是需要键入abckeys。如果想完全封杀某条命令，可以将该指令rename成空字符串，就无法通过任务字符指令来执行这条命令了</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rename-command</span> <span class="selector-tag">flushdb</span> &quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="端口安全"><a href="#端口安全" class="headerlink" title="端口安全"></a>端口安全</h3><p>Redis默认会监听6379端口，如果当前的服务器主机有外网地址，Redis的服务将会直接暴露在公网上，任何一个初级黑客都可以使用工具对IP地址进行端口扫描就可以探测出来</p>
<p>Redis的服务地址一旦可以被外网直接访问，内部的数据就彻底失去了安全性。高级一点的黑客们可以通过Redis指令Lua脚本拿到服务器权限，恶意的对手们甚至会直接清空你的Redis数据库</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bind</span> 10.0.0.50	</span><br></pre></td></tr></table></figure>
<p>所以，运维人员务必在Redis的配置文件中指定监听的IP地址，避免这样的发生。更进一步，还可以增加Redis的密码访问限制，客户端必须使用auth指令，传入正确的密码才可以访问Redis，这样即使地址暴露出去了，普通黑客也无法对Redis进行任何指令操作</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">requirepass</span> !<span class="selector-tag">idf3Bf3</span>*&amp;</span><br></pre></td></tr></table></figure>
<p>密码控制也会影响到从节点复制，从节点必须在配置文件里使用masterauth指令配置相应的密码才可以进行复制操作</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">masterauth</span>  !<span class="selector-tag">idf3Bf3</span>*&amp;</span><br></pre></td></tr></table></figure>
<p>验证方法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/redis/6379.conf</span><br><span class="line"><span class="selector-tag">requirepass</span> !<span class="selector-tag">idf3Bf3</span>*&amp;</span><br><span class="line">$ redis-server /etc/redis/6379.conf</span><br><span class="line">$ redis-cli -p 6379</span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line">(<span class="selector-tag">error</span>) <span class="selector-tag">NOAUTH</span> <span class="selector-tag">Authentication</span> <span class="selector-tag">required</span>.</span><br><span class="line">&gt; <span class="selector-tag">auth</span> !<span class="selector-tag">idf3Bf3</span>*&amp;</span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line">&gt; <span class="selector-tag">set</span> <span class="selector-tag">k1</span> <span class="selector-tag">v1</span></span><br><span class="line"><span class="selector-tag">OK</span></span><br><span class="line"></span><br><span class="line">// 或下述这种，但是这种不安全</span><br><span class="line">$ redis-cli -p 6379 -a 123456  </span><br><span class="line">Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.</span><br></pre></td></tr></table></figure>
<h3 id="SSL代理"><a href="#SSL代理" class="headerlink" title="SSL代理"></a>SSL代理</h3><p>Redis以前的版本并不支持SSL连接，说明客户端和服务器之间交互的数据不应该直接暴露在公网上传输，否则会有窃听数据的风险。如果必须要用在公网上，可以考虑使用SSL代理</p>
<p>SSL里常见的有SSH，不过Redis官方推荐使用spiped工具，可能是因为spiped的功能相对单一，使用起来简单，易于理解</p>
<p>下图是spiped对ssh通道进行二次加密（因为SSH通道也可以存在bug）</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210510094439991.png"></p>
<p>同样SSL代理也可以用在主从复制上，如果Redis主从实例需要跨机房复制，spiped就能排上用场</p>
<h3 id="Redis安全通信"><a href="#Redis安全通信" class="headerlink" title="Redis安全通信"></a>Redis安全通信</h3><p>想到一个应用场景，公司有两个机房。因为一个紧急需求，需要跨机房读取Redis数据。应用部署在A机房，存储部署在B机房。如果使用普通TCP直接访问，数据的传输就会暴露在公网上，这是非常不安全的。客户端服务器交互的数据存在被窃听的风险。如图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210510102843215.png"></p>
<p>Redis本身并不支持SSL安全链接，不过有了SSL代理软件，可以让通信数据得到加密，使用Redis推荐的代理软件spiped，如下图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210510103243499.png">    </p>
<h3 id="spiped原理"><a href="#spiped原理" class="headerlink" title="spiped原理"></a>spiped原理</h3><p>spiped会在客户端和服务器各启动一个spiped进程</p>
<p>左边的spiped进程负责接受来自Redis Client发送过来的请求数据，加密后传送到右边的spiped进程。右边的spiped进程将接收到的数据解密后传递到Redis Server。然后Redis Server再走一个反向的流程将响应回复给Redis Client。如下图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210510104217811.png"></p>
<p>每一个spiped进程都会有一个监听端口（server socket）用来接收数据，同时还会作为一个客户端（socket client）将数据转发到目标地址</p>
<p>spiped进程需要成对出现，相互之间需要使用相同的共享秘钥来加密消息</p>
<h3 id="spiped使用"><a href="#spiped使用" class="headerlink" title="spiped使用"></a>spiped使用</h3><p>准备两台主机</p>
<ul>
<li>10.0.0.50:6379(Master)</li>
<li>10.0.0.52:6379(Slave)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bind</span> 10.0.0.50</span><br><span class="line"><span class="selector-tag">bind</span> 10.0.0.52</span><br><span class="line">重启<span class="selector-tag">redis</span></span><br><span class="line"><span class="selector-tag">redis-cli</span> <span class="selector-tag">-p</span> 10.0.0.50</span><br><span class="line"><span class="selector-tag">redis-cli</span> <span class="selector-tag">-p</span> 10.0.0.52</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">wget</span> <span class="selector-tag">https</span>://<span class="selector-tag">github</span><span class="selector-class">.com</span>/<span class="selector-tag">Tarsnap</span>/<span class="selector-tag">spiped</span>/<span class="selector-tag">archive</span>/<span class="selector-tag">refs</span>/<span class="selector-tag">tags</span>/1.6.1<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">$ tar xf 1.6.1.tar.gz</span><br><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">spiped-1</span>.6.1</span><br><span class="line"><span class="selector-tag">yum</span> <span class="selector-tag">install</span> <span class="selector-tag">openssl-devel</span></span><br><span class="line"><span class="selector-tag">make</span> &amp;&amp; <span class="selector-tag">make</span> <span class="selector-tag">install</span></span><br></pre></td></tr></table></figure>
<p>生成随机的密钥文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dd if=/dev/urandom bs=32 count=1 of=spiped.key</span><br><span class="line">1+0 <span class="selector-tag">records</span> <span class="selector-tag">in</span></span><br><span class="line">1+0 <span class="selector-tag">records</span> <span class="selector-tag">out</span></span><br><span class="line">32 <span class="selector-tag">bytes</span> (32 <span class="selector-tag">B</span>) <span class="selector-tag">copied</span>, 0.000237921 <span class="selector-tag">s</span>, 134 <span class="selector-tag">kB</span>/<span class="selector-tag">s</span></span><br></pre></td></tr></table></figure>
<p>使用密钥文件启动服务器spiped进程，10.0.0.50是我本机的公网IP地址</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-d</span> 表示<span class="selector-tag">decrypt</span>（对输入数据进行解密），<span class="selector-tag">-s</span>为源监听地址，<span class="selector-tag">-t</span>为转发目标地址</span><br><span class="line">spiped -d -s &#x27;[10.0.0.50]:6479&#x27; -t &#x27;[127.0.0.1]:6379&#x27; -k spiped.key</span><br></pre></td></tr></table></figure>
<p>这个spiped进程监听公网IP的6479端口接收公网上的数据，将数据解密后转发到本机回环地址的6379端口，也就是redis-server监听的端口</p>
<p>使用密钥文件启动客户端spiped进程，10.0.0.50是我本机的公网IP地址</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="selector-tag">-e</span>表示 <span class="selector-tag">encrypt</span>，对输入数据进行加密</span><br><span class="line">spiped -e -s &#x27;[127.0.0.1]:6579&#x27; -t &#x27;[10.0.0.50]:6479&#x27; -k spiped.key</span><br></pre></td></tr></table></figure>
<p>查看spiped进程</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep spiped</span><br><span class="line"><span class="selector-tag">root</span>      64187      1  0 14<span class="selector-pseudo">:34</span> ?        00<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span> <span class="selector-tag">spiped</span> <span class="selector-tag">-d</span> <span class="selector-tag">-s</span> <span class="selector-attr">[10.0.0.50]</span><span class="selector-pseudo">:6479</span> <span class="selector-tag">-t</span> <span class="selector-attr">[127.0.0.1]</span><span class="selector-pseudo">:6379</span> <span class="selector-tag">-k</span> <span class="selector-tag">spiped</span><span class="selector-class">.key</span></span><br><span class="line"><span class="selector-tag">root</span>      64249      1  0 14<span class="selector-pseudo">:35</span> ?        00<span class="selector-pseudo">:00</span><span class="selector-pseudo">:00</span> <span class="selector-tag">spiped</span> <span class="selector-tag">-e</span> <span class="selector-tag">-s</span> <span class="selector-attr">[127.0.0.1]</span><span class="selector-pseudo">:6579</span> <span class="selector-tag">-t</span> <span class="selector-attr">[10.0.0.50]</span><span class="selector-pseudo">:6479</span> <span class="selector-tag">-k</span> <span class="selector-tag">spiped</span><span class="selector-class">.key</span></span><br></pre></td></tr></table></figure>
<p>客户端spiped进程监听了本地回环地址的6579端口，将该端口上收到的数据加密转发到服务器spiped进程</p>
<p>启动客户端连接，使用python代码来启动redis的客户端</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">import</span> <span class="selector-tag">redis</span></span><br><span class="line">&gt;&gt;&gt; c=redis.StrictRedis(host=&#x27;localhost&#x27;, port=6379)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">c</span><span class="selector-class">.ping</span>()</span><br><span class="line"><span class="selector-tag">True</span></span><br><span class="line">&gt;&gt;&gt; c.info(&#x27;cpu&#x27;)</span><br><span class="line">&#123;&#x27;used_cpu_sys&#x27;: 0.408888, &#x27;used_cpu_user&#x27;: 0.475312, &#x27;used_cpu_sys_children&#x27;: 0.004183, &#x27;used_cpu_user_children&#x27;: 0.0&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出客户端和服务已经通了，如果我们尝试直接连接服务器spiped进程（加密的端口6379），看看会发生什么</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">import</span> <span class="selector-tag">redis</span></span><br><span class="line">&gt;&gt;&gt; c=redis.StrictRedis(host=&#x27;10.0.0.50&#x27;, port=6479)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">c</span><span class="selector-class">.ping</span>()</span><br><span class="line"><span class="selector-tag">Traceback</span> (<span class="selector-tag">most</span> <span class="selector-tag">recent</span> <span class="selector-tag">call</span> <span class="selector-tag">last</span>):</span><br><span class="line">  <span class="selector-tag">File</span> &quot;&lt;<span class="selector-tag">stdin</span>&gt;&quot;, <span class="selector-tag">line</span> 1, <span class="selector-tag">in</span> &lt;<span class="selector-tag">module</span>&gt;</span><br><span class="line">  <span class="selector-tag">File</span> &quot;/<span class="selector-tag">usr</span>/<span class="selector-tag">local</span>/<span class="selector-tag">lib</span>/<span class="selector-tag">python3</span>.6/<span class="selector-tag">site-packages</span>/<span class="selector-tag">redis</span>/<span class="selector-tag">client</span><span class="selector-class">.py</span>&quot;, <span class="selector-tag">line</span> 1378, <span class="selector-tag">in</span> <span class="selector-tag">ping</span></span><br><span class="line">    return self.execute_command(&#x27;PING&#x27;)</span><br><span class="line">  <span class="selector-tag">File</span> &quot;/<span class="selector-tag">usr</span>/<span class="selector-tag">local</span>/<span class="selector-tag">lib</span>/<span class="selector-tag">python3</span>.6/<span class="selector-tag">site-packages</span>/<span class="selector-tag">redis</span>/<span class="selector-tag">client</span><span class="selector-class">.py</span>&quot;, <span class="selector-tag">line</span> 901, <span class="selector-tag">in</span> <span class="selector-tag">execute_command</span></span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">self</span><span class="selector-class">.parse_response</span>(<span class="selector-tag">conn</span>, <span class="selector-tag">command_name</span>, **<span class="selector-tag">options</span>)</span><br><span class="line">  <span class="selector-tag">File</span> &quot;/<span class="selector-tag">usr</span>/<span class="selector-tag">local</span>/<span class="selector-tag">lib</span>/<span class="selector-tag">python3</span>.6/<span class="selector-tag">site-packages</span>/<span class="selector-tag">redis</span>/<span class="selector-tag">client</span><span class="selector-class">.py</span>&quot;, <span class="selector-tag">line</span> 915, <span class="selector-tag">in</span> <span class="selector-tag">parse_response</span></span><br><span class="line">    response = connection.read_response()</span><br><span class="line">  <span class="selector-tag">File</span> &quot;/<span class="selector-tag">usr</span>/<span class="selector-tag">local</span>/<span class="selector-tag">lib</span>/<span class="selector-tag">python3</span>.6/<span class="selector-tag">site-packages</span>/<span class="selector-tag">redis</span>/<span class="selector-tag">connection</span><span class="selector-class">.py</span>&quot;, <span class="selector-tag">line</span> 739, <span class="selector-tag">in</span> <span class="selector-tag">read_response</span></span><br><span class="line">    response = self._parser.read_response()</span><br><span class="line">  <span class="selector-tag">File</span> &quot;/<span class="selector-tag">usr</span>/<span class="selector-tag">local</span>/<span class="selector-tag">lib</span>/<span class="selector-tag">python3</span>.6/<span class="selector-tag">site-packages</span>/<span class="selector-tag">redis</span>/<span class="selector-tag">connection</span><span class="selector-class">.py</span>&quot;, <span class="selector-tag">line</span> 324, <span class="selector-tag">in</span> <span class="selector-tag">read_response</span></span><br><span class="line">    raw = self._buffer.readline()</span><br><span class="line">  <span class="selector-tag">File</span> &quot;/<span class="selector-tag">usr</span>/<span class="selector-tag">local</span>/<span class="selector-tag">lib</span>/<span class="selector-tag">python3</span>.6/<span class="selector-tag">site-packages</span>/<span class="selector-tag">redis</span>/<span class="selector-tag">connection</span><span class="selector-class">.py</span>&quot;, <span class="selector-tag">line</span> 256, <span class="selector-tag">in</span> <span class="selector-tag">readline</span></span><br><span class="line">    <span class="selector-tag">self</span>._<span class="selector-tag">read_from_socket</span>()</span><br><span class="line">  <span class="selector-tag">File</span> &quot;/<span class="selector-tag">usr</span>/<span class="selector-tag">local</span>/<span class="selector-tag">lib</span>/<span class="selector-tag">python3</span>.6/<span class="selector-tag">site-packages</span>/<span class="selector-tag">redis</span>/<span class="selector-tag">connection</span><span class="selector-class">.py</span>&quot;, <span class="selector-tag">line</span> 201, <span class="selector-tag">in</span> _<span class="selector-tag">read_from_socket</span></span><br><span class="line">    <span class="selector-tag">raise</span> <span class="selector-tag">ConnectionError</span>(<span class="selector-tag">SERVER_CLOSED_CONNECTION_ERROR</span>)</span><br><span class="line"><span class="selector-tag">redis</span><span class="selector-class">.exceptions</span><span class="selector-class">.ConnectionError</span>: <span class="selector-tag">Connection</span> <span class="selector-tag">closed</span> <span class="selector-tag">by</span> <span class="selector-tag">server</span>.</span><br></pre></td></tr></table></figure>
<p>从输出中可以看出请求时发送过去了，但是却出现了超时，要么是服务器在默认的超时时间内内有返回数据，要么是服务器没有返回客户端想要的数据</p>
<p>spiped可以同时支持多个客户端连接的数据转发工作，还可以通过参数来限定允许的最大客户端连接数，但是对于服务器spiped，它不能同时支持多个服务器之间的转发。这意味着在集群环境下，需要为每个server节点启动一个spiped进程来代收消息</p>
<h3 id="redis6-0版本支持SSL-TLS"><a href="#redis6-0版本支持SSL-TLS" class="headerlink" title="redis6.0版本支持SSL/TLS"></a>redis6.0版本支持SSL/TLS</h3><p>Redis从版本6开始支持SSL/TLS，这是一项可选功能，需要在编译时启用</p>
<h4 id="SSL-TLS配置"><a href="#SSL-TLS配置" class="headerlink" title="SSL/TLS配置"></a>SSL/TLS配置</h4><p><strong>构建</strong></p>
<p>要使用TLS支持进行构建，需要OpenSSL 开发库，运行make BUILD_TLS=yes</p>
<p>要使用TLS运行Redis测试套件，需要TLS支持TCL（即tcl-tls包）</p>
<ul>
<li>运行 <code>./utils/gen-test-certs.sh</code>生成根CA和服务器证书</li>
<li>运行<code>./runtest --tls</code> or <code>./runtest-cluster --tls</code>运行Redis和Redis集群</li>
</ul>
<p><strong>手动运行</strong></p>
<p>要以TLS模式手动运行Redis服务器（假设已调用gen-test-certs.sh，因此示例证书/密钥可用）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./<span class="selector-tag">src</span>/<span class="selector-tag">redis-server</span> <span class="selector-tag">--tls-port</span> 6379 <span class="selector-tag">--port</span> 0 \</span><br><span class="line">    <span class="selector-tag">--tls-cert-file</span> ./<span class="selector-tag">tests</span>/<span class="selector-tag">tls</span>/<span class="selector-tag">redis</span><span class="selector-class">.crt</span> \</span><br><span class="line">    <span class="selector-tag">--tls-key-file</span> ./<span class="selector-tag">tests</span>/<span class="selector-tag">tls</span>/<span class="selector-tag">redis</span><span class="selector-class">.key</span> \</span><br><span class="line">    <span class="selector-tag">--tls-ca-cert-file</span> ./<span class="selector-tag">tests</span>/<span class="selector-tag">tls</span>/<span class="selector-tag">ca</span><span class="selector-class">.crt</span></span><br></pre></td></tr></table></figure>
<p>使用redis-cli连接Redis服务器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./<span class="selector-tag">src</span>/<span class="selector-tag">redis-cli</span> <span class="selector-tag">--tls</span> \</span><br><span class="line">    <span class="selector-tag">--cert</span> ./<span class="selector-tag">tests</span>/<span class="selector-tag">tls</span>/<span class="selector-tag">redis</span><span class="selector-class">.crt</span> \</span><br><span class="line">    <span class="selector-tag">--key</span> ./<span class="selector-tag">tests</span>/<span class="selector-tag">tls</span>/<span class="selector-tag">redis</span><span class="selector-class">.key</span> \</span><br><span class="line">    <span class="selector-tag">--cacert</span> ./<span class="selector-tag">tests</span>/<span class="selector-tag">tls</span>/<span class="selector-tag">ca</span><span class="selector-class">.crt</span></span><br></pre></td></tr></table></figure>
<p><strong>证书配置</strong></p>
<p>为了支持TLS，Redis必须配置x.509证书和密钥。另外，在验证证书时，必须指定可信任根的CA证书捆绑文件或路径。为了支持基于DH密钥，还可以配置DH 参数文件。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tls-cert-file</span> /<span class="selector-tag">path</span>/<span class="selector-tag">to</span>/<span class="selector-tag">redis</span><span class="selector-class">.crt</span></span><br><span class="line"><span class="selector-tag">tls-key-file</span> /<span class="selector-tag">path</span>/<span class="selector-tag">to</span>/<span class="selector-tag">redis</span><span class="selector-class">.key</span></span><br><span class="line"><span class="selector-tag">tls-ca-cert-file</span> /<span class="selector-tag">path</span>/<span class="selector-tag">to</span>/<span class="selector-tag">ca</span><span class="selector-class">.crt</span></span><br><span class="line"><span class="selector-tag">tls-dh-params-file</span> /<span class="selector-tag">path</span>/<span class="selector-tag">to</span>/<span class="selector-tag">redis</span><span class="selector-class">.dh</span></span><br></pre></td></tr></table></figure>
<h4 id="TLS端口侦听"><a href="#TLS端口侦听" class="headerlink" title="TLS端口侦听"></a>TLS端口侦听</h4><p>tls-port配置伪指令可在指定端口上接收SSL/TLS连接，这不仅是侦听TCP连接的端口，还同时使用TLS和non-TLS连接访问不同端口上的Redis</p>
<p>你可以指定port 0以完全禁用non-TLS端口，仅在默认Redis端口上启动TLS，如下述操作</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">port</span> 0</span><br><span class="line"><span class="selector-tag">tls0port</span> 6379</span><br></pre></td></tr></table></figure>
<h4 id="客户端认证证书"><a href="#客户端认证证书" class="headerlink" title="客户端认证证书"></a>客户端认证证书</h4><p>默认情况下，Redis使用双向TLS并要求客户端使用有效证书进行身份认证（根据ca-cert-file<code>or</code>ca-cert-dir指定受信任的根CA进行身份认证）</p>
<p>你可以使用tls-auth-clients no 去禁用客户端身份认证</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>Redis master服务以相同方法处理连接客户端和副本服务器，因此上述tls-port 和 tls-auth-clients指令也适用于复制链接</p>
<p>在副本服务端，必须指定tls-replication yes才能使用TLS到主服务器的传出连接</p>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><p>使用Redis集群时，则使用tls-cluster yes以便为了启动集群总线和跨节点连接TLS</p>
<h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>Sentinel从通过redis配置继承其网咯配置，因此上述所有内容都适用于sentinel</p>
<p>连接master服务器时，Sentinel使用tls-replication指令来确定是否需要使用TLS和non-TLS连接</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Inaction</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://myboke.ink/2021/05/10/Redis扩展功能-4（Pipeline、事务与Bloom等）/">https://myboke.ink/2021/05/10/Redis扩展功能-4（Pipeline、事务与Bloom等）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/05/10/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-5/"><i class="fa fa-chevron-left">  </i><span>Redis消息队列-5</span></a></div><div class="next-post pull-right"><a href="/2021/05/08/Redis%E6%8C%81%E4%B9%85%E5%8C%96-3%EF%BC%88RDB%E4%B8%8EAOF%EF%BC%89/"><span>Redis持久化-3（RDB与AOF）</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6cea6a646bff1a0d5f5b',
  clientSecret: '6e9ef08f31f505d416bc0afe2d304808e9063627',
  repo: 'zsjmal2316.github.io',
  owner: 'zsjmal2316',
  admin: 'zsjmal2316',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(img/wuwei.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Inaction</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">粤ICP备20067869号<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="120" alpha="0.3" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>