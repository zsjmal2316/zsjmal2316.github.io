<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="MySQL存储引擎-5"><meta name="keywords" content="MySQL"><meta name="author" content="Inaction"><meta name="copyright" content="Inaction"><title>MySQL存储引擎-5 | Inaction's Blog</title><link rel="shortcut icon" href="/imdadul-hussain-u_oLPS_ZYSc-unsplash.jpg"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?12b421fdad87d1edf2305ccb7229d2c1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-8RMJ1F8ETC', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">存储引擎介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">InnoDB体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BInnoDB%E7%8A%B6%E6%80%81%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">1.3.</span> <span class="toc-text">查看InnoDB状态的技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bshow-engine-innodb-status%E4%BF%9D%E7%95%99%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">如何查看show engine innodb status保留下的内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">1.4.</span> <span class="toc-text">InnoDB的多线程技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E7%BC%93%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF"><span class="toc-number">1.5.</span> <span class="toc-text">InnoDB的缓存池管理技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E8%84%8F%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">InnoDB中的脏页管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">InnoDB的日志管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.8.</span> <span class="toc-text">InnoDB中的检查机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%AF%B4%E6%98%8E"><span class="toc-number">1.9.</span> <span class="toc-text">InnoDB存储引擎核心特性说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">1.10.</span> <span class="toc-text">InnoDB存储引擎的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E5%A4%9A%E5%BC%A0innoDB%E4%B8%BAtokudb"><span class="toc-number">1.10.1.</span> <span class="toc-text">批量替换多张innoDB为tokudb</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%88%E8%A1%A8%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.11.</span> <span class="toc-text">InnoDB存储引擎物理存储结构（表空间）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9B%B4%E8%A7%82%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%88-data-mysql-data"><span class="toc-number">1.11.1.</span> <span class="toc-text">最直观的存储方式（&#x2F;data&#x2F;mysql&#x2F;data)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.11.2.</span> <span class="toc-text">共享表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E8%A1%A8%E7%A9%BA%E9%97%B4%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.3.</span> <span class="toc-text">共享表空间设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">1.11.4.</span> <span class="toc-text">独立表空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.5.</span> <span class="toc-text">独立表空间设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4%E8%BF%81%E7%A7%BB"><span class="toc-number">1.11.6.</span> <span class="toc-text">独立表空间迁移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.12.</span> <span class="toc-text">InnoDB核心特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.12.1.</span> <span class="toc-text">为什么需要事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E7%9A%84%E4%BA%8B%E5%8A%A1%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.2.</span> <span class="toc-text">标准的事务语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E4%BF%AE%E6%94%B9%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E6%9C%BA%E5%88%B6%E5%8F%82%E6%95%B0"><span class="toc-number">1.12.3.</span> <span class="toc-text">在线修改自动提交机制参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.12.4.</span> <span class="toc-text">隐式提交的情况（重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81"><span class="toc-number">1.12.5.</span> <span class="toc-text">事务的ACID如何保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E2%80%93redo-%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97"><span class="toc-number">1.12.6.</span> <span class="toc-text">事务日志–redo(重做日志)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%E2%80%93undo%EF%BC%88%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-number">1.12.7.</span> <span class="toc-text">事务日志–undo（回滚日志）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%92%8CMVCC"><span class="toc-number">1.13.</span> <span class="toc-text">锁和MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84MVCC"><span class="toc-number">1.13.1.</span> <span class="toc-text">MySQL中的MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88transaction-isolation%EF%BC%89"><span class="toc-number">1.13.2.</span> <span class="toc-text">事务隔离级别（transaction_isolation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABRU%E3%80%81RR%E5%92%8CRC"><span class="toc-number">1.13.3.</span> <span class="toc-text">MySQL中的隔离级别RU、RR和RC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RU-%E8%84%8F%E8%AF%BB"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">RU-脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RC-%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">RC-幻读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RR-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.13.3.3.</span> <span class="toc-text">RR-不可重复读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">1.14.</span> <span class="toc-text">MySQL锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.1.</span> <span class="toc-text">MySQL锁的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8A%A0%E9%94%81%E7%9A%84%E8%BF%87%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.14.2.</span> <span class="toc-text">索引加锁的过程的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A1%88%E5%88%97"><span class="toc-number">1.14.3.</span> <span class="toc-text">死锁案列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#insert%E8%AF%AD%E5%8F%A5%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">insert语句导致的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">事务提交导致的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">事务回滚导致的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E5%88%97%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">1.14.3.4.</span> <span class="toc-text">自增列导致的死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delete-%E5%92%8C-insert%E6%B7%B7%E5%90%88%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">1.14.3.5.</span> <span class="toc-text">delete 和 insert混合的死锁</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/imdadul-hussain-u_oLPS_ZYSc-unsplash.jpg"></div><div class="author-info__name text-center">Inaction</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">50</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">19</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">13</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Friend Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://www.ji4n.cn/">Jen</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(img/beijing2.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Inaction's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">MySQL存储引擎-5</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-03-02</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/">Linux</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/MySQL/">MySQL</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h2><p>存储引擎相当于Linux文件系统，只不过比文件系统强大，存储引擎是MySQL核心组件之一，在MySQL中是以插件的形式来提供的，InnoDB是MySQL最流行的存储引擎，XtraDB是Percona分支的默认存储引擎，可以理解是InnoDB的定制透明版本，TokuDB适合密集型写入的存储引擎，压缩比较高。我们可以在不同的业务场景下选择合适的存储引擎</p>
<p><strong>查看MySQL支持的存储引擎</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">show</span> <span class="selector-tag">engines</span>;</span><br><span class="line">+<span class="selector-tag">--------------------</span>+<span class="selector-tag">---------</span>+<span class="selector-tag">----------------------------------------------------------------</span>+<span class="selector-tag">--------------</span>+<span class="selector-tag">------</span>+<span class="selector-tag">------------</span>+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+<span class="selector-tag">--------------------</span>+<span class="selector-tag">---------</span>+<span class="selector-tag">----------------------------------------------------------------</span>+<span class="selector-tag">--------------</span>+<span class="selector-tag">------</span>+<span class="selector-tag">------------</span>+</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">+<span class="selector-tag">--------------------</span>+<span class="selector-tag">---------</span>+<span class="selector-tag">----------------------------------------------------------------</span>+<span class="selector-tag">--------------</span>+<span class="selector-tag">------</span>+<span class="selector-tag">------------</span>+</span><br></pre></td></tr></table></figure>
<p><strong>查看MySQL默认使用的存储引擎</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@default_storage_engine</span>;</span><br><span class="line">+<span class="selector-tag">--------------------------</span>+</span><br><span class="line">| @@default_storage_engine |</span><br><span class="line">+<span class="selector-tag">--------------------------</span>+</span><br><span class="line">| InnoDB                   |</span><br><span class="line">+<span class="selector-tag">--------------------------</span>+</span><br></pre></td></tr></table></figure>
<p><strong>查看world库中所有表使用的存储引擎</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT table_schema,table_name,ENGINE FROM information_schema.tables WHERE table_schema IN (&#x27;world&#x27;);</span><br><span class="line">+<span class="selector-tag">--------------</span>+<span class="selector-tag">-----------------</span>+<span class="selector-tag">--------</span>+</span><br><span class="line">| table_schema | table_name      | ENGINE |</span><br><span class="line">+<span class="selector-tag">--------------</span>+<span class="selector-tag">-----------------</span>+<span class="selector-tag">--------</span>+</span><br><span class="line">| world        | city            | InnoDB |</span><br><span class="line">| world        | country         | InnoDB |</span><br><span class="line">| world        | countrylanguage | InnoDB |</span><br><span class="line">+<span class="selector-tag">--------------</span>+<span class="selector-tag">-----------------</span>+<span class="selector-tag">--------</span>+</span><br></pre></td></tr></table></figure>
<p><strong>配置MySQL使用的存储引擎</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/my.cnf</span><br><span class="line">default_storage_engine=InnoDB</span><br></pre></td></tr></table></figure>
<h2 id="InnoDB体系结构"><a href="#InnoDB体系结构" class="headerlink" title="InnoDB体系结构"></a>InnoDB体系结构</h2><p>下图分三个部分，上面的是缓存层，中间是线程层，下面是系统文件层。在每个层里面又会不断地细分，在MySQL里面存储的单位是页，大小是16K，缓存层包含buffer和cache，其中buffer对应缓存修改的数据（比如insert buffer）。cache对应缓存读取的舒适（比如page cache），通过缓存可以提高MySQL读写数据的效率</p>
<p>系统文件层是相应的<strong>数据字典、数据文件和日志文件</strong>，其中binlog是MySQL Server层</p>
<p>多线程设计是InnoDB的一大亮点，通过多线程的方式可以把缓存层与系统文件层的操作高效组织起来，使得Innodb可以提供完整的数据服务</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210301113303766.png"></p>
<h2 id="查看InnoDB状态的技巧"><a href="#查看InnoDB状态的技巧" class="headerlink" title="查看InnoDB状态的技巧"></a>查看InnoDB状态的技巧</h2><p>MySQL中如果要查看InnoDB的状态，推荐的方式是使用命令<code>show engine innodb status</code>.</p>
<p>头部内容信息显示当前的日期和时间，以及自上次输出依赖经过的时长，从时间和描述可看到这个命令的输出不是实时的结果</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">show</span> <span class="selector-tag">engine</span> <span class="selector-tag">innodb</span> <span class="selector-tag">status</span>\<span class="selector-tag">G</span>:</span><br><span class="line">*************************** 1. <span class="selector-tag">row</span> ***************************</span><br><span class="line">  <span class="selector-tag">Type</span>: <span class="selector-tag">InnoDB</span></span><br><span class="line">  <span class="selector-tag">Name</span>: </span><br><span class="line"><span class="selector-tag">Status</span>: </span><br><span class="line">=====================================</span><br><span class="line">2021<span class="selector-tag">-02-18</span> 22<span class="selector-pseudo">:30</span><span class="selector-pseudo">:51</span> 0<span class="selector-tag">x7fe3880f4700</span> <span class="selector-tag">INNODB</span> <span class="selector-tag">MONITOR</span> <span class="selector-tag">OUTPUT</span></span><br><span class="line">=====================================</span><br><span class="line"><span class="selector-tag">Per</span> <span class="selector-tag">second</span> <span class="selector-tag">averages</span> <span class="selector-tag">calculated</span> <span class="selector-tag">from</span> <span class="selector-tag">the</span> <span class="selector-tag">last</span> 5 <span class="selector-tag">seconds</span></span><br></pre></td></tr></table></figure>
<h3 id="如何查看show-engine-innodb-status保留下的内容"><a href="#如何查看show-engine-innodb-status保留下的内容" class="headerlink" title="如何查看show engine innodb status保留下的内容"></a>如何查看show engine innodb status保留下的内容</h3><p><strong>1. 首先查看mysqld的进程号</strong></p>
<p>可以看到要找的进程号是：9315</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef|grep mysqld|grep -v grep</span><br><span class="line">mysql      2846      1  0 Feb16 ?        00:03:04 /application/mysql/bin/mysqld --defaults-file=/data/3309/my.cnf</span><br><span class="line">mysql      2880      1  0 Feb16 ?        00:03:14 /application/mysql/bin/mysqld --defaults-file=/data/3308/my.cnf</span><br><span class="line">mysql      2914      1  0 Feb16 ?        00:03:12 /application/mysql/bin/mysqld --defaults-file=/data/3307/my.cnf</span><br><span class="line">root       9138      1  0 01:46 ?        00:00:00 /bin/sh /application/mysql/bin/mysqld_safe --datadir=/data/mysql/data --pid-file=/data/mysql/data/mysql.pid</span><br><span class="line">mysql      9315   9138  0 01:46 ?        00:02:00 /application/mysql/bin/mysqld --basedir=/application/mysql --datadir=/data/mysql/data --plugin-dir=/application/mysql/lib/plugin --user=mysql --log-error=mysql.err --pid-file=/data/mysql/data/mysql.pid --socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>
<p><strong>2. 在操作系统层面查看上述MySQL的句柄，显示如下</strong></p>
<p>但是这么多文件，无法判定那个文件是要我们找的</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$  ll /proc/9315/fd|grep deleted</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 12 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibC9Z4PI</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 27 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">test</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 28 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">test1</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 29 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">binlog</span>/<span class="selector-tag">t1</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 5 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibRoyuZC</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 6 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibdDJsjf</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 7 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibkyUxDR</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 8 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibIk2Dm6</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 90 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">pp</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">lrwx------</span>. 1 <span class="selector-tag">root</span> <span class="selector-tag">root</span> 64 <span class="selector-tag">Feb</span> 18 22<span class="selector-pseudo">:25</span> 91 <span class="selector-tag">-</span>&gt; /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">t100</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br></pre></td></tr></table></figure>
<p><strong>3. 可以根据lsof命令来输出句柄信息，显示如下</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -c mysqld|grep deleted</span><br><span class="line"><span class="selector-tag">mysqld</span>    2914 <span class="selector-tag">mysql</span>   12<span class="selector-tag">u</span>   <span class="selector-tag">REG</span>              253,0         0 17215061 /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibYlTgqJ</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld_sa</span> 9138  <span class="selector-tag">root</span>    2<span class="selector-tag">u</span>   <span class="selector-tag">CHR</span>              136,3       0<span class="selector-tag">t0</span>        6 /<span class="selector-tag">dev</span>/<span class="selector-tag">pts</span>/3 (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>    5<span class="selector-tag">u</span>   <span class="selector-tag">REG</span>              253,0      4363 16777294 /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibRoyuZC</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>    6<span class="selector-tag">u</span>   <span class="selector-tag">REG</span>              253,0        97 16778321 /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibdDJsjf</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>    7<span class="selector-tag">u</span>   <span class="selector-tag">REG</span>              253,0         0 16785261 /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibkyUxDR</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>    8<span class="selector-tag">u</span>   <span class="selector-tag">REG</span>              253,0         0 17458882 /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibIk2Dm6</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>   12<span class="selector-tag">u</span>   <span class="selector-tag">REG</span>              253,0         0 17458885 /<span class="selector-tag">tmp</span>/<span class="selector-tag">ibC9Z4PI</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>   27<span class="selector-tag">uW</span>  <span class="selector-tag">REG</span>               8,16     98304  8416762 /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">test</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>   28<span class="selector-tag">uW</span>  <span class="selector-tag">REG</span>               8,16     98304  8416764 /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">test1</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>   29<span class="selector-tag">uW</span>  <span class="selector-tag">REG</span>               8,16     98304  8416768 /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">binlog</span>/<span class="selector-tag">t1</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>   90<span class="selector-tag">uW</span>  <span class="selector-tag">REG</span>               8,16     98304  8416760 /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">pp</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br><span class="line"><span class="selector-tag">mysqld</span>    9315 <span class="selector-tag">mysql</span>   91<span class="selector-tag">uW</span>  <span class="selector-tag">REG</span>               8,16  79691776  8416757 /<span class="selector-tag">data</span>/<span class="selector-tag">mysql</span>/<span class="selector-tag">data</span>/<span class="selector-tag">world</span>/<span class="selector-tag">t100</span><span class="selector-class">.ibd</span> (<span class="selector-tag">deleted</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：如果没有该命令，则使用该命令下载：yum install -y lsof</p>
</blockquote>
<p>需要注意第7列，可以看到只有两个是有数据的，分别查看一下就得到show engine innodb status的输出结果，即文件/tmp/ibRoyuZC，而映射的是5号文件</p>
<p><strong>4. 查看5号文件，得到信息</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/<span class="selector-tag">proc</span>/9315/<span class="selector-tag">fd</span></span><br><span class="line">$ cat 5</span><br><span class="line"></span><br><span class="line">=====================================</span><br><span class="line">2021<span class="selector-tag">-02-18</span> 22<span class="selector-pseudo">:30</span><span class="selector-pseudo">:51</span> 0<span class="selector-tag">x7fe3880f4700</span> <span class="selector-tag">INNODB</span> <span class="selector-tag">MONITOR</span> <span class="selector-tag">OUTPUT</span></span><br><span class="line">=====================================</span><br><span class="line"><span class="selector-tag">Per</span> <span class="selector-tag">second</span> <span class="selector-tag">averages</span> <span class="selector-tag">calculated</span> <span class="selector-tag">from</span> <span class="selector-tag">the</span> <span class="selector-tag">last</span> 5 <span class="selector-tag">seconds</span></span><br></pre></td></tr></table></figure>
<h2 id="InnoDB的多线程技术"><a href="#InnoDB的多线程技术" class="headerlink" title="InnoDB的多线程技术"></a>InnoDB的多线程技术</h2><p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210301123223470.png" alt="."></p>
<p>InnoDB的线程主要分为4类：Master Thread、IO Thread、Purge Thread和Page Cleaner Thread</p>
<p>Master Thread是InnoDB的核心线程，早期的很多事情都是由它来做，算是一个全栈线程。自MySQL 5.5版开始引入了purge thread，将purge任务从master中独立出来，到MySQL 5.6.2版开始引入了Page cleaner thread</p>
<table>
<thead>
<tr>
<th>线程</th>
<th>功能描述</th>
<th>相关数据库参数</th>
</tr>
</thead>
<tbody><tr>
<td>Master Thread</td>
<td>是核心的后台线程，主要负责异步刷新和数据一致性处理</td>
<td></td>
</tr>
<tr>
<td>IO Thread</td>
<td>使用了异步IO模型，负责处理不同类型的IO请求回调</td>
<td>innodb_read_io_threads、innodb_write_io_threads</td>
</tr>
<tr>
<td>Purge Thread</td>
<td>事务提交后回收已经使用并分配的undo页，线程数从1提高到4，加快标记为废弃undo页的回收速度</td>
<td>innodb_purge_threads</td>
</tr>
<tr>
<td>Page Cleaner Thread</td>
<td>执行buffer pool里面脏页刷新操作，可以进行调整，默认为1，最大为64</td>
<td>innodb_page_cleaners</td>
</tr>
</tbody></table>
<p>其中Master Thread在输出如下：测试环境下，没有什么负载，其中srv_master_thread loops是Master线程的循环次数，每次循环时会选择一种状态（atcive、shutdown、idle）执行，其中Active数量增加与数据变化有关，与查询无关，可以通过srv_active和srv_idle的差异看出</p>
<p>通过对比active和idle的值，来获取系统整体负载情况，如果Active的值越大，证明服务越繁忙。这里是测试环境，所以idle多余active</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">BACKGROUND</span> <span class="selector-tag">THREAD</span></span><br><span class="line"><span class="selector-tag">-----------------</span></span><br><span class="line"><span class="selector-tag">srv_master_thread</span> <span class="selector-tag">loops</span>: 70 <span class="selector-tag">srv_active</span>, 0 <span class="selector-tag">srv_shutdown</span>, 75924 <span class="selector-tag">srv_idle</span></span><br><span class="line"><span class="selector-tag">srv_master_thread</span> <span class="selector-tag">log</span> <span class="selector-tag">flush</span> <span class="selector-tag">and</span> <span class="selector-tag">writes</span>: 75994</span><br></pre></td></tr></table></figure>
<p>IO thread都是异步请求，其中read thread默认为4个，write thread默认为4个，log thread和insert buffer thread各1个，read和write都可以通过上述表格参数调整</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">--------</span></span><br><span class="line"><span class="selector-tag">FILE</span> <span class="selector-tag">I</span>/<span class="selector-tag">O</span></span><br><span class="line"><span class="selector-tag">--------</span></span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 0 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">insert</span> <span class="selector-tag">buffer</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 1 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">log</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 2 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">read</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 3 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">read</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 4 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">read</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 5 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">read</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 6 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">write</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 7 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">write</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 8 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">write</span> <span class="selector-tag">thread</span>)</span><br><span class="line"><span class="selector-tag">I</span>/<span class="selector-tag">O</span> <span class="selector-tag">thread</span> 9 <span class="selector-tag">state</span>: <span class="selector-tag">waiting</span> <span class="selector-tag">for</span> <span class="selector-tag">completed</span> <span class="selector-tag">aio</span> <span class="selector-tag">requests</span> (<span class="selector-tag">write</span> <span class="selector-tag">thread</span>)</span><br></pre></td></tr></table></figure>
<p>Purge thread默认会开启4个线程，提高回收效率，但是也会带来一些副作用，MySQL如果执行了truncate和drop操作，因为开启了多个purge thread去回收空间，随着时间的推移会使得数据恢复难打加大</p>
<p>Page Cleaner thread默认值为1，如果在MySQL日志中看到如下的信息，说明我们需要调整一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019 <span class="selector-tag">-</span> 02 <span class="selector-tag">-</span> 14<span class="selector-tag">T23</span> : 50 : 00 . 501209<span class="selector-tag">Z</span> 0 <span class="selector-attr">[Note]</span> <span class="selector-tag">InnoDB</span>: <span class="selector-tag">page_cleaner</span> : 1<span class="selector-tag">OOOms</span> <span class="selector-tag">intended</span></span><br><span class="line">loop took 28469710ms . The settings m工ght not be optimal . (flushed=O and</span><br><span class="line">evicted=O , during the time.)</span><br></pre></td></tr></table></figure>
<h2 id="InnoDB的缓存池管理技术"><a href="#InnoDB的缓存池管理技术" class="headerlink" title="InnoDB的缓存池管理技术"></a>InnoDB的缓存池管理技术</h2><p>Buffer的本意是缓冲，cache是缓存，计算机术语里面有buffer cache和page cache，与数据库的含义是相似的</p>
<p>计算机领域汇总处理磁盘IO读写时候，基于CPU、Memory和Disk，如图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210301133510778.png"></p>
<p>page cache是文件系统层面的缓存，数据库层面最直观就是首次查询数据的时候会慢一些，之后就会使用缓存会快速很多，整个过程是把磁盘里的数据里的一部分数据加载到缓存中</p>
<p>buffer cache，是在写入磁盘时给与的缓冲，加快写入，是一个异步过程，而且为了防止断电丢失数据库，会按照一定的策略把数据刷新到磁盘</p>
<p>理解MySQL里面的缓存池管理，使用show engine innodb status看一下缓冲池和内存输出内容，通过关键字“BUFFER POOL AND MEMORY”找到该位置</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">----------------------</span></span><br><span class="line"><span class="selector-tag">BUFFER</span> <span class="selector-tag">POOL</span> <span class="selector-tag">AND</span> <span class="selector-tag">MEMORY</span></span><br><span class="line"><span class="selector-tag">----------------------</span></span><br><span class="line"><span class="selector-tag">Total</span> <span class="selector-tag">large</span> <span class="selector-tag">memory</span> <span class="selector-tag">allocated</span> 137428992              //由<span class="selector-tag">innodb</span>分配的总内存为12<span class="selector-tag">G</span></span><br><span class="line"><span class="selector-tag">Dictionary</span> <span class="selector-tag">memory</span> <span class="selector-tag">allocated</span> 221523                  //由<span class="selector-tag">innodb</span>分配的字典内容</span><br><span class="line"><span class="selector-tag">Buffer</span> <span class="selector-tag">pool</span> <span class="selector-tag">size</span>   8191                             //缓冲池分配的页数</span><br><span class="line"><span class="selector-tag">Free</span> <span class="selector-tag">buffers</span>       1455                             //缓冲空闲页数</span><br><span class="line"><span class="selector-tag">Database</span> <span class="selector-tag">pages</span>     6736                             //<span class="selector-tag">LRU</span>列表中分配的数据页数，包含<span class="selector-tag">young</span> <span class="selector-tag">sublist</span>和<span class="selector-tag">old</span> <span class="selector-tag">sublist</span></span><br><span class="line"><span class="selector-tag">Old</span> <span class="selector-tag">database</span> <span class="selector-tag">pages</span> 2500                             //<span class="selector-tag">LRU</span>中的<span class="selector-tag">old</span> <span class="selector-tag">sublist</span>部分页的数量</span><br><span class="line"><span class="selector-tag">Modified</span> <span class="selector-tag">db</span> <span class="selector-tag">pages</span>  0                                //脏页的数量</span><br><span class="line"><span class="selector-tag">Pending</span> <span class="selector-tag">reads</span>      0                                //挂起读的数量</span><br><span class="line"><span class="selector-tag">Pending</span> <span class="selector-tag">writes</span>: <span class="selector-tag">LRU</span> 0, <span class="selector-tag">flush</span> <span class="selector-tag">list</span> 0, <span class="selector-tag">single</span> <span class="selector-tag">page</span> 0  //挂起写的数量</span><br><span class="line"><span class="selector-tag">Pages</span> <span class="selector-tag">made</span> <span class="selector-tag">young</span> 0, <span class="selector-tag">not</span> <span class="selector-tag">young</span> 0                     //<span class="selector-tag">LRU</span>列表，页移动到<span class="selector-tag">LRU</span>首部的次数，因为该服务器运行阶段没有达到<span class="selector-tag">innodb</span> <span class="selector-tag">old</span> <span class="selector-tag">blocks</span> <span class="selector-tag">time</span>阈值的值，因此<span class="selector-tag">not</span> <span class="selector-tag">young</span>为0</span><br><span class="line">0.00 <span class="selector-tag">youngs</span>/<span class="selector-tag">s</span>, 0.00 <span class="selector-tag">non-youngs</span>/<span class="selector-tag">s</span>                    //表示每秒<span class="selector-tag">young</span>和<span class="selector-tag">non-young</span>操作次数</span><br><span class="line"><span class="selector-tag">Pages</span> <span class="selector-tag">read</span> 6676, <span class="selector-tag">created</span> 60, <span class="selector-tag">written</span> 328            //读取、创建、写入的页</span><br><span class="line">0.00 <span class="selector-tag">reads</span>/<span class="selector-tag">s</span>, 0.00 <span class="selector-tag">creates</span>/<span class="selector-tag">s</span>, 0.00 <span class="selector-tag">writes</span>/<span class="selector-tag">s</span></span><br><span class="line"><span class="selector-tag">No</span> <span class="selector-tag">buffer</span> <span class="selector-tag">pool</span> <span class="selector-tag">page</span> <span class="selector-tag">gets</span> <span class="selector-tag">since</span> <span class="selector-tag">the</span> <span class="selector-tag">last</span> <span class="selector-tag">printout</span></span><br><span class="line"><span class="selector-tag">Pages</span> <span class="selector-tag">read</span> <span class="selector-tag">ahead</span> 0.00/<span class="selector-tag">s</span>, <span class="selector-tag">evicted</span> <span class="selector-tag">without</span> <span class="selector-tag">access</span> 0.00/<span class="selector-tag">s</span>, <span class="selector-tag">Random</span> <span class="selector-tag">read</span> <span class="selector-tag">ahead</span> 0.00/<span class="selector-tag">s</span></span><br><span class="line"><span class="selector-tag">LRU</span> <span class="selector-tag">len</span>: 6736, <span class="selector-tag">unzip_LRU</span> <span class="selector-tag">len</span>: 0</span><br></pre></td></tr></table></figure>
<p>LRU本质是尽可能让数据页在缓存中长时间保留，提高访问效率，但是缓存是有限的，如何减少重复的页加载频率。</p>
<p>InnoDB的LRU是一种定制化的算法，首先它会有一个列表，我们叫 LRU LIST，上面存放了一些数据页，这里就是 Database pages 6736，除此之外可用的页为 ： Free buffers 1455，演示的是测试环境，所以对于生产环境会有所不同（如果你比较细心比较，会发现 Free buffers +Database pages 的值和 Buffer pool size 的大小是不相等的 ， 其实还有一些其他缓冲池的页被分配利用，比如自适应哈希索引、 Lock信息等，它们的管理不是基于LRU 的） </p>
<p>回到 LRU 算法， InnoDB 在 LRU 列表中加入了参考点，也叫midpoint。 传统的 LRU 算法中 ，当访问到的<strong>页不在缓冲区</strong>会直接将<strong>磁盘页数据</strong>调到<strong>缓冲区队列</strong>；而 InnoDB 并不是直接插入到缓冲区队列的队头，而是插入 LRU 列表的<strong>midpoint位置</strong>。 这个算法称之为 midpoint insertion stategy（中点插入策略）。默认配置插入到列表长度的 5/8 处 ，和数学中的黄金分割（ 0.618 ）很接近，midpoint 由参数 innodb_old_blocks_pct 控制，简单验算验证一下 ，可以看到是很接近的值   </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">select</span> 5/8 , 1<span class="selector-tag">-</span> 120340/326446 , 100 <span class="selector-tag">-</span> @<span class="keyword">@innodb_old_blocks_pct</span>;</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">------------------</span>+<span class="selector-tag">-------------------------------</span>+</span><br><span class="line">| 5/8    | 1- 120340/326446 | 100 - @@innodb_old_blocks_pct |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">------------------</span>+<span class="selector-tag">-------------------------------</span>+</span><br><span class="line">| 0.6250 |           0.6314 |                            63 |</span><br><span class="line">+<span class="selector-tag">--------</span>+<span class="selector-tag">------------------</span>+<span class="selector-tag">-------------------------------</span>+</span><br></pre></td></tr></table></figure>
<p>midpoint 之前的列表称之为Sublist of new列表， 也叫young sublist 或者 sublist of new block 区域 ，里面的数据可以理解为热数据，之后的列表称之为Sublist of old 列表 ，也叫old sublist 或者 sublist of old block 区域</p>
<p><strong>关系图如下</strong></p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210515220434520.png"></p>
<p>一些全表扫描的表如果进入 sublist of new block 区域 ，整个 LRU 就会是性能瓶颈了，而且 midpoint 位置的页也不是永久的，这种情况也叫缓存污染。为了解决这个问题 ，InnoDB 存储引擎引入了 innodb_old_blocks_time 来表示页读取到 mid 位置之后需要等待多久才会被加入到 LRU 列表的热端。可以通过设置该参数来保证热点数据不轻易被刷出,这个参数值默认为 1000 （毫秒）。</p>
<p>如果出现了多个BUFFER POOL的输出，BUFFER POOL会从0开始；通过该参数进行调整：innodb_buffer_pool_instances开启多个缓存池，把需要的数据页可以通过hash算法指向不同的缓存池里面，可以并行的内存读写，在高IO负载的情况下性能提升明显</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@innodb_buffer_pool_instances</span>;</span><br><span class="line">+<span class="selector-tag">--------------------------------</span>+</span><br><span class="line">| @@innodb_buffer_pool_instances |</span><br><span class="line">+<span class="selector-tag">--------------------------------</span>+</span><br><span class="line">|                              1 |</span><br><span class="line">+<span class="selector-tag">--------------------------------</span>+</span><br></pre></td></tr></table></figure>
<h2 id="InnoDB中的脏页管理"><a href="#InnoDB中的脏页管理" class="headerlink" title="InnoDB中的脏页管理"></a>InnoDB中的脏页管理</h2><p>上述说明了InnoDB对于LRU的管理方式，还有FLUSH LIST和FREE LIST，它们和LUR LIST有什么关系呢？</p>
<p><strong>在InnoDB status里面输出的内容,这个free buffers是由FREE LIST来维护的</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Free</span> <span class="selector-tag">buffers</span>       1455</span><br></pre></td></tr></table></figure>
<p>对于脏页的管理，InnoDB有一个专门的列表FLUSH LIST，它的大小不是无限大或者动态的，在MySQL5.6版本中引入了新参数innodb_lru_scan_depth来控制LRU列表中可用页数量，默认值为1024，即16M，它会影响现成Page Cleaner 刷新脏页的数量，从使用率和性能来说，不是越大越好</p>
<p>为什么FLUSH LIST来维护脏页的和数量，主要目的是让InnoDB尽可能保持一个较新的状态，在系统崩溃之后能够快速地恢复，这个在数据状态的记录汇总是通过Checkpoint LSN来维护的、</p>
<p>而对于脏页的刷新比例，是由参数 innodb_max_dirty_pages_pct 来控制的（默认是75 ，而根据谷歌压测推荐是80 ）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@innodb_max_dirty_pages_pct</span>;</span><br><span class="line">+<span class="selector-tag">------------------------------</span>+</span><br><span class="line">| @@innodb_max_dirty_pages_pct |</span><br><span class="line">+<span class="selector-tag">------------------------------</span>+</span><br><span class="line">|                    75.000000 |</span><br><span class="line">+<span class="selector-tag">------------------------------</span>+</span><br></pre></td></tr></table></figure>
<p><strong>LIST之间的关系图</strong></p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210219161723158.png"></p>
<p><strong>其中buffer pool中的最小单位是页，分为三种类型</strong></p>
<ul>
<li><p>free page：此page未被使用，此种类型page位于FREE LIST中</p>
</li>
<li><p>clean page：此page被使用，对应数据文件中的一个页面，但是页面没有被修改，此种类型page位于LRU LIST中</p>
</li>
<li><p>dirty page：此page被使用，对应数据文件中的一个页面，但是页面被修改过，此种类型page位于LRU LIST和FLUSH LIST中</p>
</li>
</ul>
<p><strong>可以通过下述方法查看page的状态数据</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; show global status like &#x27;%buffer_pool_pages%&#x27;;</span><br><span class="line">+<span class="selector-tag">----------------------------------</span>+<span class="selector-tag">-------</span>+</span><br><span class="line">| Variable_name                    | Value |</span><br><span class="line">+<span class="selector-tag">----------------------------------</span>+<span class="selector-tag">-------</span>+</span><br><span class="line">| Innodb_buffer_pool_pages_data    | 6736  |</span><br><span class="line">| Innodb_buffer_pool_pages_dirty   | 0     |</span><br><span class="line">| Innodb_buffer_pool_pages_flushed | 328   |</span><br><span class="line">| Innodb_buffer_pool_pages_free    | 1455  |</span><br><span class="line">| Innodb_buffer_pool_pages_misc    | 0     |</span><br><span class="line">| Innodb_buffer_pool_pages_total   | 8191  |</span><br><span class="line">+<span class="selector-tag">----------------------------------</span>+<span class="selector-tag">-------</span>+</span><br></pre></td></tr></table></figure>
<p><strong>其中，脏页的比率计算可以参考如下：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(100*<span class="selector-tag">Innodb_buffer_pool_pages_dirty</span>)/(1+<span class="selector-tag">Innodb_buffer_pool_pages_data</span>+<span class="selector-tag">Innodb_buffer_pool_pages_free</span>)</span><br></pre></td></tr></table></figure>
<p>缓存池中的页就是在这种状态中变换和调整：总体来说，FLUSH LIST是一种定量的管理方式，追求多块好省，而FREE LIST和LRU LIST是一种动态平衡的状态，大小要远远高于FLUSH LIST</p>
<h2 id="InnoDB的日志管理"><a href="#InnoDB的日志管理" class="headerlink" title="InnoDB的日志管理"></a>InnoDB的日志管理</h2><p>InnoDB里面的数据变化都会有相应的页来存储，通过FLUSH LIST来刷新脏页以完成数据落盘，这个过程还需要注意，为了提高吞吐量和性能，刷新脏页的过程是异步的，而一旦数据库崩溃，如何保证数据的完整性，首选得有记录数据变化过程的日志</p>
<ul>
<li>REDO日志：Innodb的事务日志，保存在日志文件ib_logfile</li>
<li>UNDO lOG日志：存放在共享表空间里面（ibdata*文件）</li>
</ul>
<p>假设我们有如下一条SQL语句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update test set id=100;</span><br></pre></td></tr></table></figure>
<p>在InnoDB处理的时候，会把相应的页加载到Buffer Pool里面，数据的变化会写入redo log buffer，而事务提交的时候会通过Redo Log Buffer把数据变化写入Redo Log里面</p>
<p><strong>为什么Binlog和Redo会并存</strong></p>
<ul>
<li>Redo是Innodb引擎的范畴，记录物理页的修改，做崩溃恢复时所用</li>
<li>Binlog是MySQL Server范畴，记录的是数据的变更操作，支持多种存储引擎，也就是无论是MyISAM和Innodb等存储引擎，Binlog都会记录，所以数据恢复和搭建Slave经常会用来</li>
</ul>
<p><strong>一次数据变更，产生了Binlog和Redo，它们是否需要同步</strong></p>
<p>需要两个重量级参数<code>innodb_flush_log_at_trx_commit和sync_binlog</code>，其中<code>innodb_flush_log_at_trx_commit</code>是将事务日志从innodb log buffer写入到redo log中，sync_binlog是将二进制日志文件刷新到磁盘上，它们就是行业里著名的双<code>“1”</code>参数，其中以innodb_flush_log_at_trx_commit更为出名</p>
<p><strong>下表是innodb_flush_log_at_trx_commit=x的参数</strong></p>
<table>
<thead>
<tr>
<th>参数选项</th>
<th>日志写入模式</th>
<th>刷盘模式</th>
<th>小结</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>延时写日志</td>
<td></td>
<td>log buffer每个1秒写日志，数据刷盘</td>
<td>最快，存在数据丢失风险</td>
</tr>
<tr>
<td>1</td>
<td>实时写日志</td>
<td>实时刷盘</td>
<td>log buffer实时写日志，数据刷盘</td>
<td>最大安全性</td>
</tr>
<tr>
<td>2</td>
<td>实时写日志</td>
<td>延迟刷盘</td>
<td>log buffer实时写日志，每隔1秒刷盘</td>
<td>较快，存在数据丢失风险</td>
</tr>
</tbody></table>
<blockquote>
<p>PS：在数据导入中，为了提高性能，可以考虑临时调整参数值innodb_flush_log_at_trx_commit为0，数据导入后，恢复为1</p>
</blockquote>
<p>下图可以对双 1 参数做一各更为细致地解读，可以看到一各较为完整的生命周期</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210301163433167.png"></p>
<p>undo记录了数据修改的前镜像。存放在ibdata中，它就好比是一个摄像机，记录了过去的美好时光</p>
<h2 id="InnoDB中的检查机制"><a href="#InnoDB中的检查机制" class="headerlink" title="InnoDB中的检查机制"></a>InnoDB中的检查机制</h2><p>如果数据库宕机，可以借助redo来完成崩溃恢复，如何使用恢复的过程高效可行，就需要考虑检查点机制（checkpoint)，检查点机制就跟我们使用word编辑文件一样&gt;建议大家使用过程中边编辑边保存，否则电脑突然断电，可能照成数据丢失</p>
<p>对于InnoDB存储引擎而言，是通过LSN（Log Sequence Number）来标记版本的。LSN是8字节的数字，每个页有LSN，重做日志中也有LSN，Checkpoint也有LSN。可以看下InnoDB status的输出内容</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">LOG</span></span><br><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">Log</span> <span class="selector-tag">sequence</span> <span class="selector-tag">number</span> 167362280                 //<span class="selector-tag">LSN1</span>，当前系统<span class="selector-tag">LSN</span>最大值，新的事务日志，<span class="selector-tag">LSN</span>将在此基础上生成（<span class="selector-tag">LSN1</span>+新日志的大小）</span><br><span class="line"><span class="selector-tag">Log</span> <span class="selector-tag">flushed</span> <span class="selector-tag">up</span> <span class="selector-tag">to</span>   167362280                 //<span class="selector-tag">LSN2</span>，当前已经写入日志文件的<span class="selector-tag">LSN</span></span><br><span class="line"><span class="selector-tag">Pages</span> <span class="selector-tag">flushed</span> <span class="selector-tag">up</span> <span class="selector-tag">to</span> 167362280                 //<span class="selector-tag">LSN3</span>，当前最旧的脏页数据对应的<span class="selector-tag">LSN</span>，写<span class="selector-tag">Checkpoint</span>的时候直接将此<span class="selector-tag">LSN</span>写入到日志文件</span><br><span class="line"><span class="selector-tag">Last</span> <span class="selector-tag">checkpoint</span> <span class="selector-tag">at</span>  167362271                 //<span class="selector-tag">LSN4</span>，当前已经写入<span class="selector-tag">Checkpoint</span>的<span class="selector-tag">LSN</span></span><br><span class="line">0 <span class="selector-tag">pending</span> <span class="selector-tag">log</span> <span class="selector-tag">flushes</span>, 0 <span class="selector-tag">pending</span> <span class="selector-tag">chkp</span> <span class="selector-tag">writes</span></span><br><span class="line">53 log i/o&#x27;s done, 0.00 log i/o&#x27;s/second</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：以上4个LSN是递减的，即：LSN1&gt;=LSN2&gt;=LSN3&gt;=LSN4</p>
</blockquote>
<p>InnoDB的checkpoint（检查点）技术很丰富，主要分为Sharp Checkpoint和Fuzzy Checkpoint两类。</p>
<ul>
<li>Sharp Checkpoint是全量检查点，在数据库关闭时将所有的脏页都刷新回磁盘，可以通过参数innodb_fast_shutdown=1来设置。</li>
<li>Fuzzy Checkpoint是模糊检查点，总体来说是部分页刷新，刷新的场景会有一些复杂，包含如下4类Checkpoint策略：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Master Thread Checkpoint</span><br><span class="line">FLUSH_LRU_LIST Checkpoint</span><br><span class="line">Async/Sync Flush Checkpoint</span><br><span class="line">Dirty Page too much Checkpoint</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Fuzzy Checkpoint策略</th>
<th>触发条件</th>
<th>描述</th>
<th>相关参数</th>
</tr>
</thead>
<tbody><tr>
<td>Master Thread Checkpoint</td>
<td>主动周期性触发</td>
<td>每秒或每10秒的速度从缓冲池的脏页列表刷新一定比例的页回磁盘</td>
<td>innodb_io_capacity</td>
</tr>
<tr>
<td>FLUSH_LRU_LIST Checkpoint</td>
<td>LRU空闲也不足</td>
<td>Page Cleaner线程中进行，用户可以通过参数innod_lru_scan_depth控制LRU列表中可用页的数量</td>
<td>innod_lru_scan_depth</td>
</tr>
<tr>
<td>Async/Sync Flush Checkpoint</td>
<td>重做日志不可用</td>
<td>重做日志文件不可用的情况，这时需要强制将一些页刷新回磁盘，而此时脏页是从FLUSH LIST中选取的</td>
<td></td>
</tr>
<tr>
<td>Dirty Page too much</td>
<td>脏页数量太多</td>
<td>脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint，其目的总的来说还是为了保证缓冲池中有足够可用的页</td>
<td>innodb_max_dirty_pages_pct</td>
</tr>
</tbody></table>
<p>其中Async/Sync Flush Checkpoint会略微复杂一些，“sync”的位置大于是redo日志的7/8，“async”位置大约是redo日志的3/4，如下图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210219171658427.png"></p>
<h2 id="InnoDB存储引擎核心特性说明"><a href="#InnoDB存储引擎核心特性说明" class="headerlink" title="InnoDB存储引擎核心特性说明"></a>InnoDB存储引擎核心特性说明</h2><p>打上*的是InnoDB重要的特性</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>支持</th>
<th>功能</th>
<th>支持</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>索引高速缓存</td>
<td>是</td>
</tr>
<tr>
<td>MVCC (Multi Version Concurrency Control)多版本并发控制*</td>
<td>是</td>
<td>数据高速缓存</td>
<td>是</td>
</tr>
<tr>
<td>B 树索引</td>
<td>是</td>
<td>自适应数列索引</td>
<td>是</td>
</tr>
<tr>
<td>群集索引</td>
<td>是</td>
<td>复制 (多线程，GTID，MTS）*</td>
<td>是</td>
</tr>
<tr>
<td>压缩数据</td>
<td>是</td>
<td>更新数据字典</td>
<td>是</td>
</tr>
<tr>
<td>加密数据</td>
<td>是</td>
<td>地理空间数据类型</td>
<td>是</td>
</tr>
<tr>
<td>事务*</td>
<td>是</td>
<td>查询高速缓存</td>
<td>是</td>
</tr>
<tr>
<td>行锁*</td>
<td>是</td>
<td>群集数据库</td>
<td>否</td>
</tr>
<tr>
<td>外键*</td>
<td>是</td>
<td>地理空间索引</td>
<td>否</td>
</tr>
<tr>
<td>备份与恢复*</td>
<td>是</td>
<td>快速索引创建</td>
<td>是</td>
</tr>
<tr>
<td>文件格式管理</td>
<td>是</td>
<td>PEFRORMANCE_SCHEMA</td>
<td>是</td>
</tr>
<tr>
<td>更改缓冲</td>
<td>是</td>
<td>自动故障恢复（ACSR）*</td>
<td>是</td>
</tr>
<tr>
<td>全文搜索扫描</td>
<td>是</td>
<td>多个缓冲池</td>
<td></td>
</tr>
</tbody></table>
<h2 id="InnoDB存储引擎的修改"><a href="#InnoDB存储引擎的修改" class="headerlink" title="InnoDB存储引擎的修改"></a>InnoDB存储引擎的修改</h2><p><strong>1. 修改存储引擎</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; alter table city engine=innodb;</span><br></pre></td></tr></table></figure>
<p><strong>2. 整理碎片</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; alter table city engine=innodb;</span><br></pre></td></tr></table></figure>
<p>这条命令可以当做整理碎片，每次使用delect删除行，都会产生碎片，从而增加数据，可以使用这条命令来解决一些碎片，当然也可以选择导出，然后删除不要的数据，在导入进MySQL，但是风险比较高</p>
<h3 id="批量替换多张innoDB为tokudb"><a href="#批量替换多张innoDB为tokudb" class="headerlink" title="批量替换多张innoDB为tokudb"></a>批量替换多张innoDB为tokudb</h3><p>单个替换</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; alter table zabbix.a engine=tokudb;</span><br></pre></td></tr></table></figure>
<p>批量替换</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; select concat(&quot;alter table &quot;,table_schema,&quot;.&quot;,table_name,&quot; &quot;,&quot;engine=toukudb&quot;) from informatiion_schema.tables where table_schema=&#x27;world&#x27;;</span><br><span class="line">+<span class="selector-tag">-------------------------------------------------------------------------</span>+</span><br><span class="line">| concat(&quot;alter table &quot;,table_schema,&quot;.&quot;,table_name,&quot; &quot;,&quot;engine=toukudb&quot;) |</span><br><span class="line">+<span class="selector-tag">-------------------------------------------------------------------------</span>+</span><br><span class="line">| alter table world.city engine=toukudb                                   |</span><br><span class="line">| alter table world.country engine=toukudb                                |</span><br><span class="line">| alter table world.countrylanguage engine=toukudb                        |</span><br><span class="line">+<span class="selector-tag">-------------------------------------------------------------------------</span>+</span><br></pre></td></tr></table></figure>
<h2 id="InnoDB存储引擎物理存储结构（表空间）"><a href="#InnoDB存储引擎物理存储结构（表空间）" class="headerlink" title="InnoDB存储引擎物理存储结构（表空间）"></a>InnoDB存储引擎物理存储结构（表空间）</h2><h3 id="最直观的存储方式（-data-mysql-data"><a href="#最直观的存储方式（-data-mysql-data" class="headerlink" title="最直观的存储方式（/data/mysql/data)"></a>最直观的存储方式（/data/mysql/data)</h3><ul>
<li>ibdata1：系统数据字典信息（统计信息），UNDO表空间等数据</li>
<li>ib_logfile0~ib_logfile1：REDO日志文件，事务日志文件</li>
<li>ibtmp1：临时表空间磁盘位置，存储临时表</li>
<li>frm：存储表的列信息</li>
<li>ibd：表的数据行和索引</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ll  | grep &quot;^-&quot;</span><br><span class="line"><span class="selector-tag">-rw-r-----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span>      620 <span class="selector-tag">Aug</span> 30 17<span class="selector-pseudo">:28</span> <span class="selector-tag">ib_buffer_pool</span></span><br><span class="line"><span class="selector-tag">-rw-r-----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span> 12582912 <span class="selector-tag">Sep</span>  3 00<span class="selector-pseudo">:34</span> <span class="selector-tag">ibdata1</span></span><br><span class="line"><span class="selector-tag">-rw-r-----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span> 50331648 <span class="selector-tag">Sep</span>  3 00<span class="selector-pseudo">:34</span> <span class="selector-tag">ib_logfile0</span></span><br><span class="line"><span class="selector-tag">-rw-r-----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span> 50331648 <span class="selector-tag">Sep</span>  3 00<span class="selector-pseudo">:34</span> <span class="selector-tag">ib_logfile1</span></span><br><span class="line"><span class="selector-tag">-rw-r-----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span> 12582912 <span class="selector-tag">Sep</span>  2 23<span class="selector-pseudo">:27</span> <span class="selector-tag">ibtmp1</span></span><br><span class="line"></span><br><span class="line">$ cd world/  </span><br><span class="line">$ ll</span><br><span class="line"><span class="selector-tag">-rw-r-----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span>     8710 <span class="selector-tag">Sep</span>  1 15<span class="selector-pseudo">:04</span> <span class="selector-tag">city</span><span class="selector-class">.frm</span></span><br><span class="line"><span class="selector-tag">-rw-r-----</span> 1 <span class="selector-tag">mysql</span> <span class="selector-tag">mysql</span>   933888 <span class="selector-tag">Sep</span>  1 15<span class="selector-pseudo">:04</span> <span class="selector-tag">city</span><span class="selector-class">.ibd</span></span><br></pre></td></tr></table></figure>
<h3 id="共享表空间"><a href="#共享表空间" class="headerlink" title="共享表空间"></a>共享表空间</h3><ul>
<li>5.5版本的默认模式，5.6中转换为了独立表空间（共享表空间，是将所有数据存储到同一个表空间(ibdata1)中，管理比较混乱）</li>
<li>5.6版本以后，共享表空间保留，只用来存储：数据字典信息(idbdata1)，undo，临时表</li>
<li>5.7版本，临时表被独立出去了</li>
<li>8.0版本，undo也被独立出去了</li>
</ul>
<p>具体变化参考官方文档:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://dev.mysql.com/doc/refman/5.6/en/innodb-architecture.html</span><br><span class="line">https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html</span><br><span class="line">https://dev.mysql.com/doc/refman/5.8/en/innodb-architecture.html</span><br></pre></td></tr></table></figure>


<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210208232415216.png"></p>
<h3 id="共享表空间设置"><a href="#共享表空间设置" class="headerlink" title="共享表空间设置"></a>共享表空间设置</h3><p>查看共享表空间的参数</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@innodb_data_file_path</span>;</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br><span class="line">| @@innodb_data_file_path |</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br><span class="line">| ibdata1:12M:autoextend  |  //共享表空间的ibdata1</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; show variables like &#x27;%autoextend%&#x27;;</span><br><span class="line">+<span class="selector-tag">-----------------------------</span>+<span class="selector-tag">-------</span>+</span><br><span class="line">| Variable_name               | Value |</span><br><span class="line">+<span class="selector-tag">-----------------------------</span>+<span class="selector-tag">-------</span>+</span><br><span class="line">| innodb_autoextend_increment | 64    |</span><br><span class="line">+<span class="selector-tag">-----------------------------</span>+<span class="selector-tag">-------</span>+</span><br></pre></td></tr></table></figure>
<p>初始化的时候添加这两条命令，可以扩展共享表空间的两个参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend</span><br><span class="line">innodb_autoextend_increment=64</span><br></pre></td></tr></table></figure>
<p>例如以下例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqld --initialize-insecure --user=mysql --basedir=xxxxxx...... innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend</span><br></pre></td></tr></table></figure>
<h3 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h3><ul>
<li><p>从5.6起默认表空间不再使用共享表空间，替换为独立表空间</p>
</li>
<li><p>存储特点为：一个表一个ibd文件，存储数据行和索引信息，frm存储表的列信息</p>
</li>
</ul>
<p><strong>5.7的独立表空间结构</strong></p>
<ul>
<li><p>一张InnoDB表 = frm+idb+ibdata1</p>
</li>
<li><p>MySQL的存储引擎日志：</p>
<p>Redo log：ib_logfile0 ib_logfile1，重做日志</p>
<p>Undo log: ibdata1 ibdata2（存储在共享表空间中），回滚日志</p>
</li>
<li><p>临时表：ibtmp1，在做join union操作产生临时数据，用完就自动清理</p>
</li>
</ul>
<h3 id="独立表空间设置"><a href="#独立表空间设置" class="headerlink" title="独立表空间设置"></a>独立表空间设置</h3><p>如果是1等于开启了独立表空间，如果是0表示没有开启</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@innodb_file_per_table</span>;</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br><span class="line">| @@innodb_file_per_table |</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br><span class="line">|                       1 |</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br></pre></td></tr></table></figure>
<p>可以修改成共享表空间</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; set global innodb_file_per_table=0;</span><br></pre></td></tr></table></figure>
<h3 id="独立表空间迁移"><a href="#独立表空间迁移" class="headerlink" title="独立表空间迁移"></a>独立表空间迁移</h3><p><strong>1. 创建和原表结构一致的空表</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; create database test charset=utf8mb4;   </span><br><span class="line"><span class="selector-tag">CREATE</span> <span class="selector-tag">TABLE</span> <span class="selector-tag">t100</span> (                           </span><br><span class="line"><span class="selector-tag">id</span> <span class="selector-tag">int</span>(11) <span class="selector-tag">DEFAULT</span> <span class="selector-tag">NULL</span>,</span><br><span class="line"><span class="selector-tag">num</span> <span class="selector-tag">int</span>(11) <span class="selector-tag">DEFAULT</span> <span class="selector-tag">NULL</span>,</span><br><span class="line"><span class="selector-tag">k1</span> <span class="selector-tag">char</span>(2) <span class="selector-tag">COLLATE</span> <span class="selector-tag">utf8mb4_bin</span> <span class="selector-tag">DEFAULT</span> <span class="selector-tag">NULL</span>,</span><br><span class="line"><span class="selector-tag">k2</span> <span class="selector-tag">char</span>(4) <span class="selector-tag">COLLATE</span> <span class="selector-tag">utf8mb4_bin</span> <span class="selector-tag">DEFAULT</span> <span class="selector-tag">NULL</span>,</span><br><span class="line"><span class="selector-tag">dt</span> <span class="selector-tag">timestamp</span> <span class="selector-tag">NOT</span> <span class="selector-tag">NULL</span> <span class="selector-tag">DEFAULT</span> <span class="selector-tag">CURRENT_TIMESTAMP</span>,</span><br><span class="line"><span class="selector-tag">KEY</span> <span class="selector-tag">id_k</span> (<span class="selector-tag">k2</span>)</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;</span><br></pre></td></tr></table></figure>
<p><strong>2. 将空表的ibd文件移动</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">alter</span> <span class="selector-tag">table</span> <span class="selector-tag">t100</span> <span class="selector-tag">discard</span> <span class="selector-tag">tablespace</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3. 将原表的idb拷贝过来</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -a test/t100w.ibd world/t100.ibd</span><br></pre></td></tr></table></figure>
<p><strong>4. 将原表ibd进行导入</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">alter</span> <span class="selector-tag">table</span> <span class="selector-tag">t100</span> <span class="selector-tag">import</span> <span class="selector-tag">tablespace</span>;</span><br></pre></td></tr></table></figure>
<p><strong>5. 总结：核心命令</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">alter</span> <span class="selector-tag">table</span> <span class="selector-tag">t100</span> <span class="selector-tag">discard</span> <span class="selector-tag">tablespace</span>;  //将创建表的空<span class="selector-tag">idb</span>丢弃</span><br><span class="line">&gt; <span class="selector-tag">alter</span> <span class="selector-tag">table</span> <span class="selector-tag">t100</span> <span class="selector-tag">import</span> <span class="selector-tag">tablespace</span>;   //将原表的<span class="selector-tag">idb</span>文件导入</span><br></pre></td></tr></table></figure>
<h2 id="InnoDB核心特性"><a href="#InnoDB核心特性" class="headerlink" title="InnoDB核心特性"></a>InnoDB核心特性</h2><h3 id="为什么需要事务"><a href="#为什么需要事务" class="headerlink" title="为什么需要事务"></a>为什么需要事务</h3><p>事务处理机制，要保证用户的数据操作是对数据“安全”的，比如我们的银行卡余额，是要绝对的安全</p>
<p><strong>事务的ACID特性</strong></p>
<ul>
<li><p>Atomit（原子性）：所有语句作为一个单元全部成功执行或全部权限，不能出现中间状态</p>
</li>
<li><p>Consistent（一致性）：如果数库在事务开启时处于一致状态，则在执行该事务期间将保留一致状态</p>
</li>
<li><p>Isolated（隔离性）：事务之间不互相影响</p>
</li>
<li><p>Durable（持久性）：事务成功完成后，所做的所有更改都会准确地记录在数据库中，所做的更改不会丢失    </p>
</li>
</ul>
<h3 id="标准的事务语句"><a href="#标准的事务语句" class="headerlink" title="标准的事务语句"></a>标准的事务语句</h3><p>DML（操作语句）：insert、update、delect</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; update city set countrycode=&#x27;CHN&#x27; where id=&#x27;1&#x27;;</span><br><span class="line">&gt; update city set countrycode=&#x27;CHN&#x27; where id=&#x27;2&#x27;;</span><br><span class="line">&gt; update city set countrycode=&#x27;CHN&#x27; where id=&#x27;3&#x27;;</span><br></pre></td></tr></table></figure>
<p>事务的结束</p>
<ul>
<li>提交：commit</li>
</ul>
<ul>
<li>回滚：rollback</li>
</ul>
<p>自动提交机制（autocommit）：默认开启</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span> @<span class="keyword">@autocommit</span>;</span><br><span class="line">+<span class="selector-tag">--------------</span>+</span><br><span class="line">| @@autocommit |</span><br><span class="line">+<span class="selector-tag">--------------</span>+</span><br><span class="line">|            1 |</span><br><span class="line">+<span class="selector-tag">--------------</span>+</span><br></pre></td></tr></table></figure>
<h3 id="在线修改自动提交机制参数"><a href="#在线修改自动提交机制参数" class="headerlink" title="在线修改自动提交机制参数"></a>在线修改自动提交机制参数</h3><p><strong>1. 会话级别：及时生效，只影响当前登录会话</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; set autocommit=0</span><br><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@autocommit</span>;</span><br><span class="line">+<span class="selector-tag">--------------</span>+</span><br><span class="line">| @@autocommit |</span><br><span class="line">+<span class="selector-tag">--------------</span>+</span><br><span class="line">|            0 |</span><br><span class="line">+<span class="selector-tag">--------------</span>+</span><br></pre></td></tr></table></figure>
<p><strong>2. 全局级别：断开窗口重连后生效，影响到所有新开的会话</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; set global autocommit=0</span><br></pre></td></tr></table></figure>
<p><strong>3. 永久修改（重启服务生效或者重启）</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/my.cnf </span><br><span class="line">autocommit=0</span><br></pre></td></tr></table></figure>
<h3 id="隐式提交的情况（重要）"><a href="#隐式提交的情况（重要）" class="headerlink" title="隐式提交的情况（重要）"></a>隐式提交的情况（重要）</h3><p><strong>触发隐式提交的语句</strong></p>
<ul>
<li>事务默认开启（begin），不能同时打开多个窗口，否则，在打开一个窗口的时候，会自动提交（commit)</li>
<li>在一个窗口执行完，再打开新的窗口</li>
</ul>
<p><strong>导致提交的非事务语句：</strong></p>
<ul>
<li>DDL语句：（ALTER，CREATE和DROP）</li>
<li>DCL语句：（GRANT，REVOKE和SET PASSWORD）</li>
<li>锁定语句：（LOCK TABLES和UNLOCK TABLES）</li>
</ul>
<p><strong>导致隐式提交的语句示例：</strong></p>
<ul>
<li>TRUNCATE TABLE</li>
<li>LOAD DATA IN FILE</li>
<li>SELECT FOR UPDATE</li>
</ul>
<h3 id="事务的ACID如何保证"><a href="#事务的ACID如何保证" class="headerlink" title="事务的ACID如何保证"></a>事务的ACID如何保证</h3><table>
<thead>
<tr>
<th>保证功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>redo log</td>
<td>重做日志</td>
</tr>
<tr>
<td>ib_logfile0-1</td>
<td>默认50M，轮询使用</td>
</tr>
<tr>
<td>redo log buffer</td>
<td>redo内存缓冲区域</td>
</tr>
<tr>
<td>data buufer pool</td>
<td>缓冲区池，数据和索引的缓冲</td>
</tr>
<tr>
<td>LSN（日志序列号）</td>
<td>MySQL每次数据库启动，都会比较磁盘数据页和redolog的LSN，必须要求LSN一致数据库才能正常启动</td>
</tr>
<tr>
<td>write adhead log</td>
<td>日志优先的方式实现持久化</td>
</tr>
<tr>
<td>脏页</td>
<td>内存脏页，内存中发生了修改，没写入到磁盘之前，内存页称之为脏页</td>
</tr>
<tr>
<td>CKPT（Checkpoint）</td>
<td>检查点，就是将脏页刷鞋到磁盘的动作</td>
</tr>
<tr>
<td>TXID（事务号）</td>
<td>InnoDB会为每一个事务生成一个事务号，伴随着整个事务</td>
</tr>
</tbody></table>
<h3 id="事务日志–redo-重做日志"><a href="#事务日志–redo-重做日志" class="headerlink" title="事务日志–redo(重做日志)"></a>事务日志–redo(重做日志)</h3><p><strong>作用：主要保证事务A(原子性)、C(一致性)、D(持久性)</strong></p>
<ul>
<li>记录了内存数据页的变化</li>
<li>提供快速的持久化功能（WAL）</li>
<li>ACSR过程中实现前滚的操作（磁盘数据页和redo日志LSN一致）</li>
</ul>
<p><strong>redo buffer：</strong></p>
<p>redo的buffer：数据页的变化信息+数据页当时的LSN号</p>
<p><strong>redo的刷写策略</strong></p>
<ul>
<li>commit;</li>
<li>刷新当前事务的redo buffer到磁盘</li>
<li>还会顺便将一部分redo buffer中没有提交的事务日志也刷新到磁盘</li>
<li>MySQL：在启动时，必须保证redo日志文件和数据文件LSN必须一致，如果不一致就会触发ACSR(自动故障恢复)，最终保证一致    </li>
</ul>
<p><strong>事务开始到事务提交，以断电后磁盘和内存是如何恢复的</strong></p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210302101841199.png"></p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210302101857768.png"></p>
<p><strong>语言描述情况：我们做一个事务，begin;update;commit</strong></p>
<ul>
<li><p>begin，立即分配一个TXID=tx_01</p>
</li>
<li><p>update时，会将需要修改的数据也（dp_01,LSN=101),加载到data buffer中</p>
</li>
<li><p>DBWR线程，会进行dp_01数据也修改更新，并更新LSN=102</p>
</li>
<li><p>LOGBWR日志写线程，会将dp_01数据页的变化+LSN+TXID存储到redo buffer</p>
</li>
<li><p>执行commit时，LGWR日志写线程会将redobuffer信息写入redolog日志文件，基于WAL原则,</p>
<p>在日志完全写入磁盘后，commit命令才执行成功,（会将此日志打上commit标记）</p>
</li>
<li><p>加入此时宕机，内存脏页没有来得及写入磁盘，内存数据全部丢失</p>
</li>
<li><p>MySQL再次重启时，必须要redolog和磁盘数据页的LSN是一致的。但是此时磁盘是LSN=101，dp_01，TXID=tx_01，redolog中LSN=102，MySQL无法正常启动，就会触发CSR（自动故障恢复），在内存追平LSN号。接着触发ckpt，将内存数据页更新到磁盘，从而保证磁盘数据页和redolog LSN一致，MySQL才能正常启动</p>
</li>
</ul>
<blockquote>
<p>PS：以上的工作过程，我们把它称之为基于REDO的“前滚操作”</p>
</blockquote>
<h3 id="事务日志–undo（回滚日志）"><a href="#事务日志–undo（回滚日志）" class="headerlink" title="事务日志–undo（回滚日志）"></a>事务日志–undo（回滚日志）</h3><p><strong>作用：在ACID特性中，主要保证A的特性，同时对CI也有一定功效</strong></p>
<ul>
<li>记录了数据修改之前的状态</li>
<li>rollback将内存的数据修改恢复到修改之前</li>
<li>在CSR中实现未提交数据的回滚操作</li>
<li>实现一致性快照，配置隔离级别保证MVCC（多版本并发控制），读和写的操作不会互相伤害</li>
</ul>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210302101959088.png"></p>
<h2 id="锁和MVCC"><a href="#锁和MVCC" class="headerlink" title="锁和MVCC"></a>锁和MVCC</h2><p>“锁”顾名思义就是锁定的意思，而锁机制（Locking）通过锁机制保证数据一致性</p>
<p><strong>锁的作用是什么</strong>：在事务ACID过程中，“锁”和“隔离级别”一起来实现“I”隔离性和”C” 一致性 </p>
<p><strong>多版本并发控制（MVCC）</strong>：MVCC（Multiversion Concurrency Control）是侧重于读写并发的改善机制，它可以避免写操作堵塞读操作的并发问题，通过使用数据的多个版本保证并发读写不冲突。它是一种标准，并不是规定了明细的实现细节，所以在数据库方向上大体会有一些MVCC的不同实现</p>
<p>如写-写的场景，为了保证在同一时间完成数据的一致性操作，需要通过锁的方式来控制，这里引出一个概念，就是2PL（Two-Phase Locking，二阶段锁），相当于加锁阶段只加锁，解锁阶段只解锁。</p>
<ul>
<li>操作数据前，加锁，互相排斥，不允许其他并发任务操作</li>
<li>操作数据后，解锁，其他任务可以继续执行</li>
</ul>
<p>读-读场景，通过行锁，可以对于读-读并发的场景有了较好的支撑。但是写入的过程中，读任务还是会被阻塞，对于读写的操作还是存在瓶颈，所以在这个层面上引入了MVCC</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获取相同数据集的排它锁</li>
</ul>
<p>简单的理解为：共享锁（S）之间不互斥，读读操作可以并行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span> * <span class="selector-tag">from</span> <span class="selector-tag">test</span> <span class="selector-tag">where</span> ..<span class="selector-class">.lock</span> <span class="selector-tag">in</span> <span class="selector-tag">share</span> <span class="selector-tag">mode</span></span><br></pre></td></tr></table></figure>
<ul>
<li>排它锁（X）：允许获得排它锁的事务更新数据，但是阻止其他事务获得相同数据集的共享锁和排它锁</li>
</ul>
<p>简单的理解为：排它锁（X）是互斥关系，读写，写写操作不可以并行</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">select</span> * <span class="selector-tag">from</span> <span class="selector-tag">test</span> <span class="selector-tag">where</span> ..<span class="selector-class">.for</span> <span class="selector-tag">update</span></span><br></pre></td></tr></table></figure>
<p>读-写场景，引出了两类读操作，快照读（Snapshot Read）和当前读（Current Read）。其中快照读-读取的是数据的可见版本，是数据历史镜像，这个过程不加锁的，而当前读-读取的是最新的版本，会加上锁，保证其他事务不会再修改这条记录</p>
<p>比如触发一条select操作：select * from test where id=10;，id为主键，这条语句对应的操作就是快照读，而上述的共享锁和排它锁的SQL，还有常见的DML都属于当前读，操作过程中会读取当前最新的版本，保证其他事务不能修改当前记录</p>
<p>比如下述例子，在窗口1没有提交之前，其他的更新会被行级锁住</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210209210439849.png"></p>
<h3 id="MySQL中的MVCC"><a href="#MySQL中的MVCC" class="headerlink" title="MySQL中的MVCC"></a>MySQL中的MVCC</h3><p>我们通过下述的图示进行说明，比如T1，T2，T3是哪个顺序时间里发生了三次请求。分别是一次写请求和两次读请求，那么在MySQL中会先在T1时间生成一个快照，比如数据标识是90，然后在这个基础上进行数据修改，数据标识为100，但事务未提交</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210511164636410.png"></p>
<p>在T1写数据事务内，T2时间的读请求会读取T1时间生成的快照数据，读取的数据标识依然是90，T3时间的读请求也是类似</p>
<p><strong>小结</strong></p>
<ul>
<li>表设计中数据生命周期的管理是一种体系化的管理方式，原理和思路是通用的</li>
<li>数据生命周期管理有两个重要得多标识，一个是标识数据变化的，一个是标识数据可用状态的</li>
</ul>
<p>假设在每行记录后面存在两个隐藏的列，这两个列分别保存了这个行的创建时间，另一个保存的是行的删除时间。这里存储的是系统版本号，会自动递增，按照DML的几个维度进行讲解</p>
<ul>
<li>Insert操作，事务id假设是1</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>create version</th>
<th>delete version</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>test</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Update操作，会先把当前记录标识为已删除，然后新增一列数据，写入相应的版本号，在这里就是2，和上一条的delete_version是一致的。比如把字段name修改为new_test</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>create version</th>
<th>delete version</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>test</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>new_test</td>
<td>2</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>delete操作，就是把当前记录标识为已删除</li>
</ul>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>create version</th>
<th>delete version</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>new_value</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>上述的实现方式中，一旦出现了事务回滚，会把已有的数据状态通过逆向应用保证事务的ACID特性</p>
<p>在InnoDB设计中，实际上所有行数据会增加以下三个内部属性列</p>
<ul>
<li>DB_TRX_ID：6字节，记录每一行最近一次修改的事务ID</li>
<li>DB_ROLL_PTP：7字节，记录指向回滚段undo日志的指针</li>
<li>DB_ROW_ID：当写入数据时，自动维护的自增列</li>
</ul>
<p>把三个列组合起来，就可以标记数据的周期性，并定位到相应的事务，在需要的时候进行回滚。比如一张test（id primary key, name）</p>
<ul>
<li>insert的数据在redo中顺序记录insert操作，同时生成undo记录，为逆操作delete</li>
<li>delete的数据在redo中顺序记录delete操作，同时生成undo记录，为逆操作insert</li>
<li>update的数据在redo中顺序记录update操作，同时生成undo记录，为逆操作update</li>
</ul>
<p>如原来id=1变成id=3，则逆操作为id=3，变成id=1</p>
<p>对于InnoDB存储引擎来说，无论是更新或是删除，都只是设置行记录上的delete BIT标记位，而不是真正的删除记录，后续这些记录的清理，是通过Purge后台进程实现的清除的</p>
<p>此外，需要使用MVCC，只有在隔离级别<code>Read-Committed(RC)和Repeatable-Read(RR)</code>才能使用，<code>Read-Uncommited(RU)</code>由于是读到为提交的，所以不存在版本的问题；而<code>Serializable</code>则会对所有读取的行加锁</p>
<h3 id="事务隔离级别（transaction-isolation）"><a href="#事务隔离级别（transaction-isolation）" class="headerlink" title="事务隔离级别（transaction_isolation）"></a>事务隔离级别（transaction_isolation）</h3><p>事务隔离级别，是为解决事务出现：脏读、不可重复读和幻读，隔离级别定义了事务之间按照什么规则进行隔离，将事务隔离到什么程序</p>
<p>脏读、不可重复读和幻读都是在读-写操作中出现的概念，可以由几下基点概括</p>
<ul>
<li>写在前，读在后：脏读</li>
<li>读在前，写在后：不可重复读</li>
<li>读在前，写在后，然后又读：幻读</li>
</ul>
<p>MySQL的四种隔离级别，默认隔离级别是Repeatable-Read（RR）</p>
<ul>
<li><p>RU（Read-Uncommitted）：读未提交，可脏读，一般不易出现</p>
</li>
<li><p>RC（Read-Committed）：读已提交，可能出现幻读，可以防止脏读</p>
</li>
<li><p>RR（Repeatable-Read）：不可重复读，功能是防止“幻读”现象，利用的是undo的快照技术+GAP（间隙锁）+ NextLock（下键锁）</p>
</li>
<li><p>SR（Serializable）：可串行化，可以防止死锁，但是并发事务性能较差（串行化隔离级别能解决上面的所有数据问题）</p>
</li>
</ul>
<blockquote>
<p>补充：在RC级别下，可以减轻GAP+NextLock锁的问题，但是会出现幻读，一般在为了读一致性会正常select后添加for update语句。但是请记住执行完一定要commit否则容易出现锁等待比较严重</p>
</blockquote>
<p><strong>查看系统使用默认隔离有以下四种</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@tx_isolation</span>;</span><br><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@session</span>.tx_isolation;</span><br><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@global</span>.tx_isolation;</span><br><span class="line">&gt; <span class="selector-tag">select</span> @<span class="keyword">@transaction_isolation</span>;</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+</span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+<span class="selector-tag">-------------------------</span>+ </span><br></pre></td></tr></table></figure>
<h3 id="MySQL中的隔离级别RU、RR和RC"><a href="#MySQL中的隔离级别RU、RR和RC" class="headerlink" title="MySQL中的隔离级别RU、RR和RC"></a>MySQL中的隔离级别RU、RR和RC</h3><p>在MySQL中有三种不同的隔离级别，我们通过下述的例子来去正确理解</p>
<h4 id="RU-脏读"><a href="#RU-脏读" class="headerlink" title="RU-脏读"></a>RU-脏读</h4><p><strong>transaction_isolation = read-uncommitted：读未提交，可脏读，一般不易出现</strong></p>
<p>设置隔离级别</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi /etc/my.cnf</span> </span><br><span class="line">transaction_isolation=read-uncommitted</span><br><span class="line"><span class="meta">#</span><span class="bash">transaction_isolation=read-committed</span></span><br><span class="line"><span class="meta">#</span><span class="bash">transaction_isolation=REPEATABLE-READ</span></span><br></pre></td></tr></table></figure>
<p>操作之前，需要查看自己是否开启自动提交</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> select @@autocommit;</span></span><br><span class="line">+--------------+</span><br><span class="line">| @@autocommit |</span><br><span class="line">+--------------+</span><br><span class="line">|            0 |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure>
<p>如果是自动提交，则修改为不自动提交</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> autocommit=0</span></span><br></pre></td></tr></table></figure>
<p>测试，写入一条更新语句，另一个窗口读取数据（这里是基于word库的city表）</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/img1/image-20210209211215566.png"></p>
<h4 id="RC-幻读"><a href="#RC-幻读" class="headerlink" title="RC-幻读"></a>RC-幻读</h4><p><strong>transaction_isolation = read-committed：读已提交，可能出现幻读，防止脏读</strong></p>
<p>创建表的时候建一个主键，主键会创建GAP+NextLock锁，阻止幻读</p>
<p>窗口1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> create table pp(id int primary key not null,name varchar(10));</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into pp values(1,<span class="string">&#x27;a&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into pp value(2,<span class="string">&#x27;b&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into pp value(5,<span class="string">&#x27;e&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> begin;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select * from pp;</span></span><br></pre></td></tr></table></figure>
<p>窗口2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> begin;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> update pp <span class="built_in">set</span> name=<span class="string">&#x27;x&#x27;</span> <span class="built_in">where</span> id&gt;2;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> commit;</span></span><br></pre></td></tr></table></figure>
<p>窗口1中的数据，就会发现原来窗口的数据发生了变化，id=2的数据列name变成了“c”。这是不可重复读的一个典型例子，会出现幻读，但是可以防止脏读。如下图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210511222703013.png"></p>
<h4 id="RR-不可重复读"><a href="#RR-不可重复读" class="headerlink" title="RR-不可重复读"></a>RR-不可重复读</h4><p><strong>transaction_isolation=REPEATABLE-READ：不可重复读，功能是防止“幻读”现象，利用的是undo的快照技术+GAP（间隙锁）+ NextLock（下键锁）</strong></p>
<p>窗口1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> create table pp(id int primary key not null,name varchar(10));</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into pp values(1,<span class="string">&#x27;a&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into pp value(2,<span class="string">&#x27;b&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into pp value(5,<span class="string">&#x27;e&#x27;</span>);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> begin;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select * from pp;</span></span><br></pre></td></tr></table></figure>
<p>窗口2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> begin;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> update pp <span class="built_in">set</span> name=<span class="string">&#x27;a&#x27;</span>;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> commit;</span></span><br></pre></td></tr></table></figure>
<p>在回到窗口1：虽然事务2已经提交，但是窗口1中的事务因为还没有提交，所以看到的还是原来的数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> select * from pp;</span></span><br></pre></td></tr></table></figure>
<p>提交事务，在查看数据变化，实际上窗口1中没有任何的DML操作，但是数据却已经改变了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> commit;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select * from pp;</span></span><br></pre></td></tr></table></figure>
<p>窗口1在没有提交前，数据还是以前的，但是使用指令commit提交后，查询的值就变成了a。虽然解决了幻读，但是会出现不可重复读</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210511223333392.png"></p>
<h2 id="MySQL锁机制"><a href="#MySQL锁机制" class="headerlink" title="MySQL锁机制"></a>MySQL锁机制</h2><h3 id="MySQL锁的类型"><a href="#MySQL锁的类型" class="headerlink" title="MySQL锁的类型"></a>MySQL锁的类型</h3><p><strong>表级意向锁</strong></p>
<p>上述有讲过InnoDB的锁，实现了两种类型的<code>行锁</code></p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同的数据集的排他锁</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，但是阻止其他事务获得相同数据集的共享锁和排他锁</li>
</ul>
<p>比喻一个场景：</p>
<p>有两个事务A和B，事务A锁住了表中的一样，加上了<code>行锁（S）</code>。即这一行<code>只能读不能写</code>、事务B申请<code>整个表的写锁</code>（在MySQL Server层可使用lock table xxxx write的方式锁表），理论上<code>B申请后就能修改表中的任意一行</code>，包括<code>S锁定的那一行</code></p>
<p>这种情况下会和<code>事务A持有的S锁冲突</code>，此时就需要一种机制来判断，从而避免这个冲突。比如需要<code>先判断是否被其他事务用表锁锁定</code>，然后<code>判断表中的每一行是否被行锁锁住</code>，当然这种方法要遍历整个表，在数据量一直增加的情况，显然这种方案不可接受的。</p>
<p>而MySQL在这种情况下，引出了意向锁来做这个冲突协调者。所以正常的流程就会为：</p>
<ul>
<li>事务A必须申请表的<code>意向共享锁（IS）</code>，成功后申请一行的<code>行锁</code></li>
<li>事务B申请<code>排他锁（X）</code>，发现表上已经有<code>意向共享锁（IS）</code>，说明表中的某些行已经被共享锁锁定了，事务<code>B申请写锁就会被阻塞</code>。</li>
</ul>
<p>而这也是为什么需要表级意向锁的主要原因，整个表意向锁的加锁过程都是自动完成，InnoDb有两个表级意向锁：</p>
<ul>
<li>意向共享锁（IS）：表示事务准备给数据行加入共享锁，加入共享锁之前必须先得到IS锁</li>
<li>意向排他锁（IX）：表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁</li>
</ul>
<p><strong>行锁</strong></p>
<p>InnoDB行锁是通过给<code>索引项加锁实现的</code>，如果<code>没有索引</code>，InnoDb会通过<code>隐式的聚集索引</code>来对记录加锁。如果不通过<code>索引条件检索数据</code>，那InnoDB将对<code>表中所有数据加锁</code>，实际效果跟表锁一行的</p>
<p>InnoDB支持如下三种行锁方式：</p>
<ul>
<li>行锁（Record Lock）：对索引项加锁，即锁定一条记录</li>
<li>间隙锁（Gap Lock）：对索引项之间的间隙，对<code>第一条记录前或最后一条记录后的间隙加锁</code>，锁定一个范围的记录，不包含记录本身</li>
<li>下键锁（Next-key Lock）：锁定一个范围的记录并包含记录本身</li>
</ul>
<p>Next-key Lock是行锁与间隙锁的组合，当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。如果一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的</p>
<p>需要知道的是：意向锁之间是互相兼容的，而不是意向锁带着S锁和X锁的组合都是互相排斥的，S锁之间是互相兼容的。如下图展示的内容</p>
<table>
<thead>
<tr>
<th></th>
<th>S（共享锁）</th>
<th>X（排他锁）</th>
<th>IS（意向共享锁）</th>
<th>IX（意向排他锁）</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p><strong>死锁</strong></p>
<p>如果锁在不兼容的情况下，通常就会产生阻塞。下述是模拟死锁的步骤：首先创建一张表test1，语句如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> create table test1 (id int unique);</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>select * from test1 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>being;<br>select * from test1 lock in share mode;</td>
</tr>
<tr>
<td>T3</td>
<td>insert into test1 values(1);——插入后会阻塞</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>insert into test1 values(2);——产生死锁</td>
</tr>
</tbody></table>
<p>share mode的方式很少使用，但很多时候会由其他的场景触发。比如对于duplicate数据的检查会开启S锁（这是比较特别的一点，需要注意）。至于死锁也会有锁的超时时间</p>
<h3 id="索引加锁的过程的差异"><a href="#索引加锁的过程的差异" class="headerlink" title="索引加锁的过程的差异"></a>索引加锁的过程的差异</h3><p>对于唯一性索引和主键，在加锁过程中存在些不同的差异。在不同的隔离级别下锁也会有相应的变化</p>
<p>创建一个表，分别创建唯一性索引和主键来演示下，表结构信息为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> create table <span class="built_in">test</span> (id int unique key, name varchar(20) primary key);</span></span><br></pre></td></tr></table></figure>
<p>插入测试数据并查看数据情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into <span class="built_in">test</span> values(1,<span class="string">&#x27;aa&#x27;</span>),(2,<span class="string">&#x27;bb&#x27;</span>),(3,<span class="string">&#x27;cc&#x27;</span>),(4,<span class="string">&#x27;dd&#x27;</span>),(5,<span class="string">&#x27;ee&#x27;</span>),(6,<span class="string">&#x27;ff&#x27;</span>)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> select * from <span class="built_in">test</span>;</span></span><br><span class="line">+------+------+</span><br><span class="line">| id   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | aa   |</span><br><span class="line">|    2 | bb   |</span><br><span class="line">|    3 | cc   |</span><br><span class="line">|    4 | dd   |</span><br><span class="line">|    5 | ee   |</span><br><span class="line">|    6 | ff   |</span><br><span class="line">+------+------+</span><br></pre></td></tr></table></figure>
<p>现在已RC隔离级别为例，触发一条SQL（select * from test where id=5 for update);加锁的情况如下图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210512123109585.png"></p>
<p>在这种情况下，select语句会根据where条件将唯一索引id=5记录加上X锁，同时得到name列，在主键聚集索引中将name=’ee’加上X锁</p>
<p>id=5和name=’ee’是指向同样的记录，为设么分这么清楚，其实可以设想这样一个场景</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210512124359795.png"></p>
<p>如果两个并发线程，线程1通过唯一性索引锁定，线程2通过主键索引来更新。如果线程1没有将主键索引上的记录加锁，那么并发线程2的update语句就会感知不到线程1的存在，会造成更新的冲突，如下图</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210512124335526.png"></p>
<p>对于唯一索引来说，加锁会有2个X锁，一个位于唯一性索引的键值记录，另外一个对应聚集索引的键值。按照这个思路，对于非唯一性索引，也会关联锁定相应的主键聚集索引项</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210512125454109.png"></p>
<p>这种场景略微复杂的一些的是基于RR隔离级别，并且是在非唯一性索引的情况下</p>
<p><img src="https://my-oss-image.oss-cn-guangzhou.aliyuncs.com/redis-pages/image-20210512125523265.png"></p>
<p>在RR隔离级别下，产生的锁的复杂度要比RC的高，会增加间隙锁。从执行的代价来看，强烈建议不要太随意的设计索引</p>
<h3 id="死锁案列"><a href="#死锁案列" class="headerlink" title="死锁案列"></a>死锁案列</h3><h4 id="insert语句导致的死锁"><a href="#insert语句导致的死锁" class="headerlink" title="insert语句导致的死锁"></a>insert语句导致的死锁</h4><p>通过三条insert导致死锁问题，我们来模拟一下这个场景</p>
<p>首先要开启参数innodb_print_all_deadlocks，将死锁日志志错误日志中，而另一个参数是5.7版本之后增加的innodb_deadlock_detect，是默认打开的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> show variables like <span class="string">&#x27;%dead%&#x27;</span>;</span></span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| innodb_deadlock_detect     | ON    |</span><br><span class="line">| innodb_print_all_deadlocks | ON    |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> global innodb_print_all_deadlocks=on</span></span><br></pre></td></tr></table></figure>
<p>在此之前，还需要关闭事务自动提交的功能</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> global autocommit = 0;</span></span><br></pre></td></tr></table></figure>
<p>创建一张tese表，建表语句如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> create table <span class="built_in">test</span> (id int primary key not null, name int unique key);</span></span><br></pre></td></tr></table></figure>
<p>模拟的步骤如下表所示：</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>insert into test values(2021,888);</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>begin<br>insert into test values(2022,888) –阻塞</td>
</tr>
<tr>
<td>T3</td>
<td>insert into test values(2023,887) –循环照成死锁</td>
<td></td>
</tr>
</tbody></table>
<p>如下是死锁的日志，可通过<code>show engine innodb status\G;</code>查看。通常来说，MySQL死锁的日志比较简略：它分为了两个事务，Transaction 1和Transaction2；日志记录的是发生死锁的临界状态的事务信息，而完整的过程是无法通过日志体现出来的。发生死锁的时候是有两个事务互相阻塞，循环造成死锁，所以要分析死锁日志，其实得到的是不够完整的信息，需要不断推导和梳理</p>
<p><code>Transaction1</code>的日志记录，事务1如果仔细查看日志会发现日志是不够完整，只打印了等待的锁，而没有持有的锁</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-05-13 21:28:21 0x7f9784305700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line"><span class="meta">#</span><span class="bash"> 阻塞了22秒钟，涉及的表1个（table <span class="keyword">in</span> use 1）</span></span><br><span class="line">TRANSACTION 1829, ACTIVE 22 sec inserting    </span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 有两个锁（一个表级意向锁，一个行锁），语句为insert into <span class="built_in">test</span> values(2022,888)</span></span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1    </span><br><span class="line">MySQL thread id 6, OS thread handle 140288734820096, query id 408 localhost root update</span><br><span class="line">insert into test values(2022,888)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 唯一的行锁处于等待状态，相关的锁等待为（lock_mode S waiting），insert通常会申请X锁（排他锁），但是这里字段对应的是一个唯一性索引，再做insert前需要做一个duplicate检查，需要申请S锁放置其他事务修改）</span></span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:    </span><br><span class="line">RECORD LOCKS space id 25 page no 4 n bits 72 index name of table `test`.`test` trx id 1829 lock mode S waiting </span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 </span><br><span class="line"> 0: len 4; hex 80000378; asc    x;;</span><br><span class="line"> 1: len 4; hex 800007e5; asc     ;;</span><br></pre></td></tr></table></figure>
<p>Transaction2的日志记录，内容会多些</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1828, ACTIVE 36 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 3, OS thread handle 140288734549760, query id 409 localhost root update</span><br><span class="line">insert into test values(2023,887)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到分为两个部分内容，一部分是持有的锁（HOLDS THE LOCK），锁默认为（lock_mode X locks rec but not gap，no gap lock）</span></span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 25 page no 4 n bits 72 index name of table `test`.`test` trx id 1828 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0 （事务2持有字段对应索引的x锁，至于具体的信息，这里看不到</span><br><span class="line">。从该语句可以得知是insert(2021,888)持有x锁）</span><br><span class="line"> 0: len 4; hex 80000378; asc    x;;</span><br><span class="line"> 1: len 4; hex 800007e5; asc     ;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 另一部分是等待的锁，锁模式为（lock_mode X waiting）。这里的S锁升级为X锁，类型是insert intention，而事务2已经申请了一个X锁，于是X锁进入队列等待，产生循环</span></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 25 page no 4 n bits 72 index name of table `test`.`test` trx id 1828 lock_mode X locks gap before rec insert intention waiting </span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000378; asc    x;;</span><br><span class="line"> 1: len 4; hex 800007e5; asc     ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure>
<p>将整个过程和死锁日志结合起来，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话2</th>
<th>会话1</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>insert into test values(2021,888);<br>持有X锁，record_lock</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>begin;<br>insert into test values(2022,888); <br>写入做duplicate冲突检测，持有S锁，等待会话1释放相关锁</td>
</tr>
<tr>
<td>T3</td>
<td>insert into test values(2023,887); <br>申请X锁，类型是insert intention，本身已有X锁，所以进入队列等待</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>两方都在互相等待，陷入僵持</td>
<td>产生死锁</td>
</tr>
</tbody></table>
<p>现在我们是模拟死锁的场景，所以我们对死锁有着更全面的信息。而在真实的环境中，我们通过死锁日志得到的结果可能是，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话2</th>
<th>会话1</th>
</tr>
</thead>
<tbody><tr>
<td>T2</td>
<td></td>
<td>begin;<br/>insert into test values(2022,888); –持有S锁</td>
</tr>
<tr>
<td>T3</td>
<td>begin;<br>insert into test values(2023,887); –申请X锁，类型是insert intention</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>产生死锁</td>
</tr>
</tbody></table>
<p>在这种情况，就需要看日志联系上下文来还原整个死锁的场景，难度比模拟场景要复杂，当然也可以多操作例子，通过举一反三来对锁机制的加深</p>
<h4 id="事务提交导致的死锁"><a href="#事务提交导致的死锁" class="headerlink" title="事务提交导致的死锁"></a>事务提交导致的死锁</h4><p>上述例子的准备操作都一样，这里不再操作。构建表信息，这里需要使用三个会话</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `dd` (</span><br><span class="line">  `id` int(10) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</span><br></pre></td></tr></table></figure>
<p>插入一条数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into d values(1);</span></span><br></pre></td></tr></table></figure>
<p>模拟的整个过程如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话1</th>
<th>会话2</th>
<th>会话3</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>beign;<br>delete from dd where id=1;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>beign;<br>insert into dd select 1;</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td></td>
<td>begin;<br>insert into dd select 1;</td>
</tr>
<tr>
<td>T4</td>
<td>commit;</td>
<td></td>
<td>照成死锁</td>
</tr>
</tbody></table>
<p>查看死锁日志如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-05-14 09:39:00 0x7f97841fd700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1844, ACTIVE 38 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 8, OS thread handle 140288733738752, query id 448 localhost root executing</span><br><span class="line">insert into dd select 1</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 26 page no 3 n bits 72 index PRIMARY of table `test`.`dd` trx id 1844 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 80000001; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000072f; asc      /;;</span><br><span class="line"> 2: len 7; hex 23000001460110; asc #   F  ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1845, ACTIVE 3 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 9, OS thread handle 140288733468416, query id 458 localhost root executing</span><br><span class="line">insert into dd select 1</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 26 page no 3 n bits 72 index PRIMARY of table `test`.`dd` trx id 1845 lock mode S locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 80000001; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000072f; asc      /;;</span><br><span class="line"> 2: len 7; hex 23000001460110; asc #   F  ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 26 page no 3 n bits 72 index PRIMARY of table `test`.`dd` trx id 1845 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 80000001; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000072f; asc      /;;</span><br><span class="line"> 2: len 7; hex 23000001460110; asc #   F  ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure>
<p>将死锁日志和加锁过程结合，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话3</th>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>delete from dd where id=1;<br>持有X锁，record lock</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>begin;<br>insert into dd select 1;<br>申请S锁，等待中</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td></td>
<td>begin;<br>insert into dd select 1;<br>申请S锁，等待中</td>
</tr>
<tr>
<td>T4</td>
<td>commit;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>成功获得S锁，请求X锁，record lock，等待会话2释放锁</td>
<td>成功获得S锁，请求X锁，record lock，等待会话1释放锁</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td></td>
<td>产生死锁，回滚</td>
</tr>
</tbody></table>
<p>过程都是在多会话并发中发生的，因为事务状态的变化导致产生了连锁反应</p>
<h4 id="事务回滚导致的死锁"><a href="#事务回滚导致的死锁" class="headerlink" title="事务回滚导致的死锁"></a>事务回滚导致的死锁</h4><p>模拟这个死锁过程，也需要开启三个会话，建表语句如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test2` (</span><br><span class="line">  `a` int(10) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">  `b` int(10) DEFAULT NULL,</span><br><span class="line">  `c` int(10) DEFAULT NULL,</span><br><span class="line">  `d` int(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`a`),</span><br><span class="line">  UNIQUE KEY `uq_bc` (`b`,`c`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line"></span><br><span class="line">//建立uq_bc的索引指令</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> alter table test2 add unique key uq_bc(b,c);</span></span><br></pre></td></tr></table></figure>
<p>插入一些数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into test2 values(10000,222,222,223),(10001,224,224,324),(10002,11,11,21);</span></span><br></pre></td></tr></table></figure>
<p>模拟整个死锁的过程，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话1</th>
<th>会话2</th>
<th>会话3</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>insert into test2 values(10003,215,215,312);</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>insert into test2 values(10004,215,215,312);</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td></td>
<td>insert into test2 values(10005,215,215,312);</td>
</tr>
<tr>
<td>T4</td>
<td>rollback;</td>
<td></td>
<td>产生死锁</td>
</tr>
</tbody></table>
<p>查看死锁相关的日志，如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-05-14 12:17:28 0x7f978423f700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1932, ACTIVE 20 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 4 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 13, OS thread handle 140288734549760, query id 878 localhost root update</span><br><span class="line">insert into test.test2 values(10004,215,215,315)</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 29 page no 4 n bits 72 index uq_bc of table `test`.`test2` trx id 1932 lock_mode X locks gap before rec insert intention waiting # S锁升级为X锁，类型insert intention</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 800000de; asc     ;;</span><br><span class="line"> 1: len 4; hex 800000de; asc     ;;</span><br><span class="line"> 2: len 4; hex 80002710; asc   &#x27; ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1933, ACTIVE 11 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">4 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 14, OS thread handle 140288733738752, query id 884 localhost root update</span><br><span class="line">insert into test.test2 values(10005,215,215,315)</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 29 page no 4 n bits 72 index uq_bc of table `test`.`test2` trx id 1933 lock mode S locks gap before rec # 做duplicate减产，持有S锁</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 800000de; asc     ;;</span><br><span class="line"> 1: len 4; hex 800000de; asc     ;;</span><br><span class="line"> 2: len 4; hex 80002710; asc   &#x27; ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 29 page no 4 n bits 72 index uq_bc of table `test`.`test2` trx id 1933 lock_mode X locks gap before rec insert intention waiting  # 锁升级由S锁升级为X锁，类型为insert intention</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 800000de; asc     ;;</span><br><span class="line"> 1: len 4; hex 800000de; asc     ;;</span><br><span class="line"> 2: len 4; hex 80002710; asc   &#x27; ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (2)</span><br></pre></td></tr></table></figure>
<p>将死锁日志和加锁过程结合，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话3</th>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>insert into test2 values(10003,215,215,312);<br>持有X锁，record_lock</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>insert into test2 values(10004,215,215,312);申请获得S锁，duplicate检查</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td></td>
<td>insert into test2 values(10005,215,215,312);<br>申请获得S锁，duplicate检查</td>
</tr>
<tr>
<td>T4</td>
<td>rollback;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>获得S锁，申请X锁，类型是insert intention，等待会话2</td>
<td>获得S锁，等待X锁，类型为insert intention，等待会话1</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td></td>
<td>回滚之后产生死锁</td>
</tr>
</tbody></table>
<p>回滚的操作与上述提交差不多，一个提交，一个回滚，都是事务状态的变化导致产生了连锁反应</p>
<h4 id="自增列导致的死锁"><a href="#自增列导致的死锁" class="headerlink" title="自增列导致的死锁"></a>自增列导致的死锁</h4><p>创建一个t2表，开启两个会话，下述是创建表的表结构</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t2` (</span><br><span class="line">  `a1` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a2` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`a1`),</span><br><span class="line">  UNIQUE KEY `a2` (`a2`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>
<p>模拟整个死锁的过程，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>beign:<br>insert into t2 values(null,10);</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>insert into t2 values(null,10);</td>
</tr>
<tr>
<td>T3</td>
<td>insert into t2 values(null,9); <br>在插入比自己大的序列不会产生死锁</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>产生死锁</td>
</tr>
</tbody></table>
<p>查看死锁相关的日志，如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-05-14 12:44:03 0x7f9784281700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1969, ACTIVE 9 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 16, OS thread handle 140288734279424, query id 1023 localhost root update</span><br><span class="line">insert into test.t2 values(null,10)</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 31 page no 4 n bits 72 index a2 of table `test`.`t2` trx id 1969 lock mode S waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 4; hex 80000004; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1968, ACTIVE 14 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 3</span><br><span class="line">MySQL thread id 7, OS thread handle 140288734009088, query id 1025 localhost root update</span><br><span class="line">insert into t2 values(null,9)</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 31 page no 4 n bits 72 index a2 of table `test`.`t2` trx id 1968 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 4; hex 80000004; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 31 page no 4 n bits 72 index a2 of table `test`.`t2` trx id 1968 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 4; hex 80000004; asc     ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure>
<p>将死锁日志和加锁过程结合，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话2</th>
<th>会话1</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>insert into t2 values(null,10);<br>持有X锁，record lock</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>insert into t2 values(null,10);<br>申请S锁</td>
</tr>
<tr>
<td>T3</td>
<td>insert into t2 values(null,9);<br>申请等待插入意向锁（insert intention），进行冲突检测，等待会话1释放锁</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>等待会话2释放列a2上的锁</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>死锁</td>
</tr>
</tbody></table>
<h4 id="delete-和-insert混合的死锁"><a href="#delete-和-insert混合的死锁" class="headerlink" title="delete 和 insert混合的死锁"></a>delete 和 insert混合的死锁</h4><p>构建表的结构信息，使用两个会话</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t1` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `a` int(10) unsigned DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `a` (`a`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>
<p>插入3条数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> insert into t1 values(1,10),(2,20),(3,30);</span></span><br></pre></td></tr></table></figure>
<p>模拟整个死锁的过程，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br>delete from t1 where a = 20;</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>beign;<br>delete from t1 where a =20;</td>
</tr>
<tr>
<td>T3</td>
<td>insert into t1 values(10,20);</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>产生死锁</td>
</tr>
</tbody></table>
<p>查看死锁相关的日志，如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line">------------------------</span><br><span class="line">2021-05-14 16:46:35 0x7f9784347700</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1990, ACTIVE 36 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)</span><br><span class="line">MySQL thread id 18, OS thread handle 140288734549760, query id 1052 localhost root updating</span><br><span class="line">delete from test.t1 where a=20</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 32 page no 4 n bits 72 index a of table `test`.`t1` trx id 1990 lock_mode X waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 00000014; asc     ;;</span><br><span class="line"> 1: len 4; hex 00000002; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1989, ACTIVE 66 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 2</span><br><span class="line">MySQL thread id 17, OS thread handle 140288734820096, query id 1053 localhost root update</span><br><span class="line">insert into t1 values(10,20)</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 32 page no 4 n bits 72 index a of table `test`.`t1` trx id 1989 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 00000014; asc     ;;</span><br><span class="line"> 1: len 4; hex 00000002; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 32 page no 4 n bits 72 index a of table `test`.`t1` trx id 1989 lock mode S waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 32</span><br><span class="line"> 0: len 4; hex 00000014; asc     ;;</span><br><span class="line"> 1: len 4; hex 00000002; asc     ;;</span><br><span class="line"></span><br><span class="line">*** WE ROLL BACK TRANSACTION (1)</span><br></pre></td></tr></table></figure>
<p>将死锁日志和加锁过程结合，如下表</p>
<table>
<thead>
<tr>
<th>发起时间</th>
<th>会话2</th>
<th>会话1</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>begin;<br/>delete from t1 where a = 20;<br>X 锁，record lock</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>begin;<br/>delete from t1 where a = 20;<br>等待X锁，record lock</td>
</tr>
<tr>
<td>T3</td>
<td>insert into t1 values(10,20);<br>申请S锁，进入等待队列</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>产生死锁，回滚</td>
</tr>
</tbody></table>
<p>在这个场景中，其实是DML之间的相互影响，上述都是单一的单向insert和单向delete</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Inaction</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://myboke.ink/2021/03/02/MySQL存储引擎-5/">https://myboke.ink/2021/03/02/MySQL存储引擎-5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/29/hexo-admin-web%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%89/"><i class="fa fa-chevron-left">  </i><span>hexo-admin(web管理界面编辑器)</span></a></div><div class="next-post pull-right"><a href="/2021/03/02/MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92-4/"><span>MySQL索引与执行计划-4</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6cea6a646bff1a0d5f5b',
  clientSecret: '6e9ef08f31f505d416bc0afe2d304808e9063627',
  repo: 'zsjmal2316.github.io',
  owner: 'zsjmal2316',
  admin: 'zsjmal2316',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(img/beijing2.png)"><div class="layout" id="footer"><div class="copyright">&copy;2020 - 2021 By Inaction</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">本网站由清远市网络安全与维护技能大师项目支持</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="120" alpha="0.3" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>